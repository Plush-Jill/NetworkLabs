// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: snakes.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_snakes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_snakes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_snakes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_snakes_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_snakes_2eproto;
namespace snakes {
class GameAnnouncement;
struct GameAnnouncementDefaultTypeInternal;
extern GameAnnouncementDefaultTypeInternal _GameAnnouncement_default_instance_;
class GameConfig;
struct GameConfigDefaultTypeInternal;
extern GameConfigDefaultTypeInternal _GameConfig_default_instance_;
class GameMessage;
struct GameMessageDefaultTypeInternal;
extern GameMessageDefaultTypeInternal _GameMessage_default_instance_;
class GameMessage_AckMsg;
struct GameMessage_AckMsgDefaultTypeInternal;
extern GameMessage_AckMsgDefaultTypeInternal _GameMessage_AckMsg_default_instance_;
class GameMessage_AnnouncementMsg;
struct GameMessage_AnnouncementMsgDefaultTypeInternal;
extern GameMessage_AnnouncementMsgDefaultTypeInternal _GameMessage_AnnouncementMsg_default_instance_;
class GameMessage_DiscoverMsg;
struct GameMessage_DiscoverMsgDefaultTypeInternal;
extern GameMessage_DiscoverMsgDefaultTypeInternal _GameMessage_DiscoverMsg_default_instance_;
class GameMessage_ErrorMsg;
struct GameMessage_ErrorMsgDefaultTypeInternal;
extern GameMessage_ErrorMsgDefaultTypeInternal _GameMessage_ErrorMsg_default_instance_;
class GameMessage_JoinMsg;
struct GameMessage_JoinMsgDefaultTypeInternal;
extern GameMessage_JoinMsgDefaultTypeInternal _GameMessage_JoinMsg_default_instance_;
class GameMessage_PingMsg;
struct GameMessage_PingMsgDefaultTypeInternal;
extern GameMessage_PingMsgDefaultTypeInternal _GameMessage_PingMsg_default_instance_;
class GameMessage_RoleChangeMsg;
struct GameMessage_RoleChangeMsgDefaultTypeInternal;
extern GameMessage_RoleChangeMsgDefaultTypeInternal _GameMessage_RoleChangeMsg_default_instance_;
class GameMessage_StateMsg;
struct GameMessage_StateMsgDefaultTypeInternal;
extern GameMessage_StateMsgDefaultTypeInternal _GameMessage_StateMsg_default_instance_;
class GameMessage_SteerMsg;
struct GameMessage_SteerMsgDefaultTypeInternal;
extern GameMessage_SteerMsgDefaultTypeInternal _GameMessage_SteerMsg_default_instance_;
class GamePlayer;
struct GamePlayerDefaultTypeInternal;
extern GamePlayerDefaultTypeInternal _GamePlayer_default_instance_;
class GamePlayers;
struct GamePlayersDefaultTypeInternal;
extern GamePlayersDefaultTypeInternal _GamePlayers_default_instance_;
class GameState;
struct GameStateDefaultTypeInternal;
extern GameStateDefaultTypeInternal _GameState_default_instance_;
class GameState_Coord;
struct GameState_CoordDefaultTypeInternal;
extern GameState_CoordDefaultTypeInternal _GameState_Coord_default_instance_;
class GameState_Snake;
struct GameState_SnakeDefaultTypeInternal;
extern GameState_SnakeDefaultTypeInternal _GameState_Snake_default_instance_;
}  // namespace snakes
PROTOBUF_NAMESPACE_OPEN
template<> ::snakes::GameAnnouncement* Arena::CreateMaybeMessage<::snakes::GameAnnouncement>(Arena*);
template<> ::snakes::GameConfig* Arena::CreateMaybeMessage<::snakes::GameConfig>(Arena*);
template<> ::snakes::GameMessage* Arena::CreateMaybeMessage<::snakes::GameMessage>(Arena*);
template<> ::snakes::GameMessage_AckMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_AckMsg>(Arena*);
template<> ::snakes::GameMessage_AnnouncementMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_AnnouncementMsg>(Arena*);
template<> ::snakes::GameMessage_DiscoverMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_DiscoverMsg>(Arena*);
template<> ::snakes::GameMessage_ErrorMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_ErrorMsg>(Arena*);
template<> ::snakes::GameMessage_JoinMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_JoinMsg>(Arena*);
template<> ::snakes::GameMessage_PingMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_PingMsg>(Arena*);
template<> ::snakes::GameMessage_RoleChangeMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_RoleChangeMsg>(Arena*);
template<> ::snakes::GameMessage_StateMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_StateMsg>(Arena*);
template<> ::snakes::GameMessage_SteerMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_SteerMsg>(Arena*);
template<> ::snakes::GamePlayer* Arena::CreateMaybeMessage<::snakes::GamePlayer>(Arena*);
template<> ::snakes::GamePlayers* Arena::CreateMaybeMessage<::snakes::GamePlayers>(Arena*);
template<> ::snakes::GameState* Arena::CreateMaybeMessage<::snakes::GameState>(Arena*);
template<> ::snakes::GameState_Coord* Arena::CreateMaybeMessage<::snakes::GameState_Coord>(Arena*);
template<> ::snakes::GameState_Snake* Arena::CreateMaybeMessage<::snakes::GameState_Snake>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace snakes {

enum GameState_Snake_SnakeState : int {
  GameState_Snake_SnakeState_ALIVE = 0,
  GameState_Snake_SnakeState_ZOMBIE = 1
};
bool GameState_Snake_SnakeState_IsValid(int value);
constexpr GameState_Snake_SnakeState GameState_Snake_SnakeState_SnakeState_MIN = GameState_Snake_SnakeState_ALIVE;
constexpr GameState_Snake_SnakeState GameState_Snake_SnakeState_SnakeState_MAX = GameState_Snake_SnakeState_ZOMBIE;
constexpr int GameState_Snake_SnakeState_SnakeState_ARRAYSIZE = GameState_Snake_SnakeState_SnakeState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameState_Snake_SnakeState_descriptor();
template<typename T>
inline const std::string& GameState_Snake_SnakeState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GameState_Snake_SnakeState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GameState_Snake_SnakeState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GameState_Snake_SnakeState_descriptor(), enum_t_value);
}
inline bool GameState_Snake_SnakeState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GameState_Snake_SnakeState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameState_Snake_SnakeState>(
    GameState_Snake_SnakeState_descriptor(), name, value);
}
enum NodeRole : int {
  NORMAL = 0,
  MASTER = 1,
  DEPUTY = 2,
  VIEWER = 3
};
bool NodeRole_IsValid(int value);
constexpr NodeRole NodeRole_MIN = NORMAL;
constexpr NodeRole NodeRole_MAX = VIEWER;
constexpr int NodeRole_ARRAYSIZE = NodeRole_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeRole_descriptor();
template<typename T>
inline const std::string& NodeRole_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NodeRole>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NodeRole_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NodeRole_descriptor(), enum_t_value);
}
inline bool NodeRole_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NodeRole* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NodeRole>(
    NodeRole_descriptor(), name, value);
}
enum PlayerType : int {
  HUMAN = 0,
  ROBOT = 1
};
bool PlayerType_IsValid(int value);
constexpr PlayerType PlayerType_MIN = HUMAN;
constexpr PlayerType PlayerType_MAX = ROBOT;
constexpr int PlayerType_ARRAYSIZE = PlayerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerType_descriptor();
template<typename T>
inline const std::string& PlayerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerType_descriptor(), enum_t_value);
}
inline bool PlayerType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerType>(
    PlayerType_descriptor(), name, value);
}
enum Direction : int {
  UP = 1,
  DOWN = 2,
  LEFT = 3,
  RIGHT = 4
};
bool Direction_IsValid(int value);
constexpr Direction Direction_MIN = UP;
constexpr Direction Direction_MAX = RIGHT;
constexpr int Direction_ARRAYSIZE = Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Direction_descriptor();
template<typename T>
inline const std::string& Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Direction_descriptor(), enum_t_value);
}
inline bool Direction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Direction>(
    Direction_descriptor(), name, value);
}
// ===================================================================

class GamePlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GamePlayer) */ {
 public:
  inline GamePlayer() : GamePlayer(nullptr) {}
  ~GamePlayer() override;
  explicit PROTOBUF_CONSTEXPR GamePlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GamePlayer(const GamePlayer& from);
  GamePlayer(GamePlayer&& from) noexcept
    : GamePlayer() {
    *this = ::std::move(from);
  }

  inline GamePlayer& operator=(const GamePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline GamePlayer& operator=(GamePlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GamePlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const GamePlayer* internal_default_instance() {
    return reinterpret_cast<const GamePlayer*>(
               &_GamePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GamePlayer& a, GamePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(GamePlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GamePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GamePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GamePlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GamePlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GamePlayer& from) {
    GamePlayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GamePlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GamePlayer";
  }
  protected:
  explicit GamePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIpAddressFieldNumber = 3,
    kIdFieldNumber = 2,
    kPortFieldNumber = 4,
    kRoleFieldNumber = 5,
    kTypeFieldNumber = 6,
    kScoreFieldNumber = 7,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string ip_address = 3;
  bool has_ip_address() const;
  private:
  bool _internal_has_ip_address() const;
  public:
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // required int32 id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // optional int32 port = 4;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // required .snakes.NodeRole role = 5;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  ::snakes::NodeRole role() const;
  void set_role(::snakes::NodeRole value);
  private:
  ::snakes::NodeRole _internal_role() const;
  void _internal_set_role(::snakes::NodeRole value);
  public:

  // optional .snakes.PlayerType type = 6 [default = HUMAN];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::snakes::PlayerType type() const;
  void set_type(::snakes::PlayerType value);
  private:
  ::snakes::PlayerType _internal_type() const;
  void _internal_set_type(::snakes::PlayerType value);
  public:

  // required int32 score = 7;
  bool has_score() const;
  private:
  bool _internal_has_score() const;
  public:
  void clear_score();
  int32_t score() const;
  void set_score(int32_t value);
  private:
  int32_t _internal_score() const;
  void _internal_set_score(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GamePlayer)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
    int32_t id_;
    int32_t port_;
    int role_;
    int type_;
    int32_t score_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameConfig) */ {
 public:
  inline GameConfig() : GameConfig(nullptr) {}
  ~GameConfig() override;
  explicit PROTOBUF_CONSTEXPR GameConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameConfig(const GameConfig& from);
  GameConfig(GameConfig&& from) noexcept
    : GameConfig() {
    *this = ::std::move(from);
  }

  inline GameConfig& operator=(const GameConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameConfig& operator=(GameConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameConfig* internal_default_instance() {
    return reinterpret_cast<const GameConfig*>(
               &_GameConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GameConfig& a, GameConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(GameConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameConfig& from) {
    GameConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameConfig";
  }
  protected:
  explicit GameConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kFoodStaticFieldNumber = 3,
    kStateDelayMsFieldNumber = 5,
  };
  // optional int32 width = 1 [default = 40];
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // optional int32 height = 2 [default = 30];
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // optional int32 food_static = 3 [default = 1];
  bool has_food_static() const;
  private:
  bool _internal_has_food_static() const;
  public:
  void clear_food_static();
  int32_t food_static() const;
  void set_food_static(int32_t value);
  private:
  int32_t _internal_food_static() const;
  void _internal_set_food_static(int32_t value);
  public:

  // optional int32 state_delay_ms = 5 [default = 1000];
  bool has_state_delay_ms() const;
  private:
  bool _internal_has_state_delay_ms() const;
  public:
  void clear_state_delay_ms();
  int32_t state_delay_ms() const;
  void set_state_delay_ms(int32_t value);
  private:
  int32_t _internal_state_delay_ms() const;
  void _internal_set_state_delay_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t width_;
    int32_t height_;
    int32_t food_static_;
    int32_t state_delay_ms_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GamePlayers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GamePlayers) */ {
 public:
  inline GamePlayers() : GamePlayers(nullptr) {}
  ~GamePlayers() override;
  explicit PROTOBUF_CONSTEXPR GamePlayers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GamePlayers(const GamePlayers& from);
  GamePlayers(GamePlayers&& from) noexcept
    : GamePlayers() {
    *this = ::std::move(from);
  }

  inline GamePlayers& operator=(const GamePlayers& from) {
    CopyFrom(from);
    return *this;
  }
  inline GamePlayers& operator=(GamePlayers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GamePlayers& default_instance() {
    return *internal_default_instance();
  }
  static inline const GamePlayers* internal_default_instance() {
    return reinterpret_cast<const GamePlayers*>(
               &_GamePlayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GamePlayers& a, GamePlayers& b) {
    a.Swap(&b);
  }
  inline void Swap(GamePlayers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GamePlayers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GamePlayers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GamePlayers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GamePlayers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GamePlayers& from) {
    GamePlayers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GamePlayers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GamePlayers";
  }
  protected:
  explicit GamePlayers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .snakes.GamePlayer players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::snakes::GamePlayer* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GamePlayer >*
      mutable_players();
  private:
  const ::snakes::GamePlayer& _internal_players(int index) const;
  ::snakes::GamePlayer* _internal_add_players();
  public:
  const ::snakes::GamePlayer& players(int index) const;
  ::snakes::GamePlayer* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GamePlayer >&
      players() const;

  // @@protoc_insertion_point(class_scope:snakes.GamePlayers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GamePlayer > players_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameState_Coord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameState.Coord) */ {
 public:
  inline GameState_Coord() : GameState_Coord(nullptr) {}
  ~GameState_Coord() override;
  explicit PROTOBUF_CONSTEXPR GameState_Coord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameState_Coord(const GameState_Coord& from);
  GameState_Coord(GameState_Coord&& from) noexcept
    : GameState_Coord() {
    *this = ::std::move(from);
  }

  inline GameState_Coord& operator=(const GameState_Coord& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameState_Coord& operator=(GameState_Coord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameState_Coord& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameState_Coord* internal_default_instance() {
    return reinterpret_cast<const GameState_Coord*>(
               &_GameState_Coord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GameState_Coord& a, GameState_Coord& b) {
    a.Swap(&b);
  }
  inline void Swap(GameState_Coord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameState_Coord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameState_Coord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameState_Coord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameState_Coord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameState_Coord& from) {
    GameState_Coord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameState_Coord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameState.Coord";
  }
  protected:
  explicit GameState_Coord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional sint32 x = 1 [default = 0];
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // optional sint32 y = 2 [default = 0];
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameState.Coord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t x_;
    int32_t y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameState_Snake final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameState.Snake) */ {
 public:
  inline GameState_Snake() : GameState_Snake(nullptr) {}
  ~GameState_Snake() override;
  explicit PROTOBUF_CONSTEXPR GameState_Snake(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameState_Snake(const GameState_Snake& from);
  GameState_Snake(GameState_Snake&& from) noexcept
    : GameState_Snake() {
    *this = ::std::move(from);
  }

  inline GameState_Snake& operator=(const GameState_Snake& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameState_Snake& operator=(GameState_Snake&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameState_Snake& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameState_Snake* internal_default_instance() {
    return reinterpret_cast<const GameState_Snake*>(
               &_GameState_Snake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GameState_Snake& a, GameState_Snake& b) {
    a.Swap(&b);
  }
  inline void Swap(GameState_Snake* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameState_Snake* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameState_Snake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameState_Snake>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameState_Snake& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameState_Snake& from) {
    GameState_Snake::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameState_Snake* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameState.Snake";
  }
  protected:
  explicit GameState_Snake(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GameState_Snake_SnakeState SnakeState;
  static constexpr SnakeState ALIVE =
    GameState_Snake_SnakeState_ALIVE;
  static constexpr SnakeState ZOMBIE =
    GameState_Snake_SnakeState_ZOMBIE;
  static inline bool SnakeState_IsValid(int value) {
    return GameState_Snake_SnakeState_IsValid(value);
  }
  static constexpr SnakeState SnakeState_MIN =
    GameState_Snake_SnakeState_SnakeState_MIN;
  static constexpr SnakeState SnakeState_MAX =
    GameState_Snake_SnakeState_SnakeState_MAX;
  static constexpr int SnakeState_ARRAYSIZE =
    GameState_Snake_SnakeState_SnakeState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SnakeState_descriptor() {
    return GameState_Snake_SnakeState_descriptor();
  }
  template<typename T>
  static inline const std::string& SnakeState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SnakeState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SnakeState_Name.");
    return GameState_Snake_SnakeState_Name(enum_t_value);
  }
  static inline bool SnakeState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SnakeState* value) {
    return GameState_Snake_SnakeState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
    kStateFieldNumber = 3,
    kHeadDirectionFieldNumber = 4,
  };
  // repeated .snakes.GameState.Coord points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::snakes::GameState_Coord* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord >*
      mutable_points();
  private:
  const ::snakes::GameState_Coord& _internal_points(int index) const;
  ::snakes::GameState_Coord* _internal_add_points();
  public:
  const ::snakes::GameState_Coord& points(int index) const;
  ::snakes::GameState_Coord* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord >&
      points() const;

  // required int32 player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  int32_t player_id() const;
  void set_player_id(int32_t value);
  private:
  int32_t _internal_player_id() const;
  void _internal_set_player_id(int32_t value);
  public:

  // required .snakes.GameState.Snake.SnakeState state = 3 [default = ALIVE];
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::snakes::GameState_Snake_SnakeState state() const;
  void set_state(::snakes::GameState_Snake_SnakeState value);
  private:
  ::snakes::GameState_Snake_SnakeState _internal_state() const;
  void _internal_set_state(::snakes::GameState_Snake_SnakeState value);
  public:

  // required .snakes.Direction head_direction = 4;
  bool has_head_direction() const;
  private:
  bool _internal_has_head_direction() const;
  public:
  void clear_head_direction();
  ::snakes::Direction head_direction() const;
  void set_head_direction(::snakes::Direction value);
  private:
  ::snakes::Direction _internal_head_direction() const;
  void _internal_set_head_direction(::snakes::Direction value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameState.Snake)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord > points_;
    int32_t player_id_;
    int state_;
    int head_direction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameState) */ {
 public:
  inline GameState() : GameState(nullptr) {}
  ~GameState() override;
  explicit PROTOBUF_CONSTEXPR GameState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameState(const GameState& from);
  GameState(GameState&& from) noexcept
    : GameState() {
    *this = ::std::move(from);
  }

  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameState& operator=(GameState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameState& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameState* internal_default_instance() {
    return reinterpret_cast<const GameState*>(
               &_GameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GameState& a, GameState& b) {
    a.Swap(&b);
  }
  inline void Swap(GameState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameState& from) {
    GameState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameState";
  }
  protected:
  explicit GameState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GameState_Coord Coord;
  typedef GameState_Snake Snake;

  // accessors -------------------------------------------------------

  enum : int {
    kSnakesFieldNumber = 2,
    kFoodsFieldNumber = 3,
    kPlayersFieldNumber = 4,
    kStateOrderFieldNumber = 1,
  };
  // repeated .snakes.GameState.Snake snakes = 2;
  int snakes_size() const;
  private:
  int _internal_snakes_size() const;
  public:
  void clear_snakes();
  ::snakes::GameState_Snake* mutable_snakes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Snake >*
      mutable_snakes();
  private:
  const ::snakes::GameState_Snake& _internal_snakes(int index) const;
  ::snakes::GameState_Snake* _internal_add_snakes();
  public:
  const ::snakes::GameState_Snake& snakes(int index) const;
  ::snakes::GameState_Snake* add_snakes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Snake >&
      snakes() const;

  // repeated .snakes.GameState.Coord foods = 3;
  int foods_size() const;
  private:
  int _internal_foods_size() const;
  public:
  void clear_foods();
  ::snakes::GameState_Coord* mutable_foods(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord >*
      mutable_foods();
  private:
  const ::snakes::GameState_Coord& _internal_foods(int index) const;
  ::snakes::GameState_Coord* _internal_add_foods();
  public:
  const ::snakes::GameState_Coord& foods(int index) const;
  ::snakes::GameState_Coord* add_foods();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord >&
      foods() const;

  // required .snakes.GamePlayers players = 4;
  bool has_players() const;
  private:
  bool _internal_has_players() const;
  public:
  void clear_players();
  const ::snakes::GamePlayers& players() const;
  PROTOBUF_NODISCARD ::snakes::GamePlayers* release_players();
  ::snakes::GamePlayers* mutable_players();
  void set_allocated_players(::snakes::GamePlayers* players);
  private:
  const ::snakes::GamePlayers& _internal_players() const;
  ::snakes::GamePlayers* _internal_mutable_players();
  public:
  void unsafe_arena_set_allocated_players(
      ::snakes::GamePlayers* players);
  ::snakes::GamePlayers* unsafe_arena_release_players();

  // required int32 state_order = 1;
  bool has_state_order() const;
  private:
  bool _internal_has_state_order() const;
  public:
  void clear_state_order();
  int32_t state_order() const;
  void set_state_order(int32_t value);
  private:
  int32_t _internal_state_order() const;
  void _internal_set_state_order(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameState)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Snake > snakes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord > foods_;
    ::snakes::GamePlayers* players_;
    int32_t state_order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameAnnouncement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameAnnouncement) */ {
 public:
  inline GameAnnouncement() : GameAnnouncement(nullptr) {}
  ~GameAnnouncement() override;
  explicit PROTOBUF_CONSTEXPR GameAnnouncement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameAnnouncement(const GameAnnouncement& from);
  GameAnnouncement(GameAnnouncement&& from) noexcept
    : GameAnnouncement() {
    *this = ::std::move(from);
  }

  inline GameAnnouncement& operator=(const GameAnnouncement& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameAnnouncement& operator=(GameAnnouncement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameAnnouncement& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameAnnouncement* internal_default_instance() {
    return reinterpret_cast<const GameAnnouncement*>(
               &_GameAnnouncement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GameAnnouncement& a, GameAnnouncement& b) {
    a.Swap(&b);
  }
  inline void Swap(GameAnnouncement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameAnnouncement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameAnnouncement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameAnnouncement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameAnnouncement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameAnnouncement& from) {
    GameAnnouncement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameAnnouncement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameAnnouncement";
  }
  protected:
  explicit GameAnnouncement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameNameFieldNumber = 4,
    kPlayersFieldNumber = 1,
    kConfigFieldNumber = 2,
    kCanJoinFieldNumber = 3,
  };
  // required string game_name = 4;
  bool has_game_name() const;
  private:
  bool _internal_has_game_name() const;
  public:
  void clear_game_name();
  const std::string& game_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_name();
  PROTOBUF_NODISCARD std::string* release_game_name();
  void set_allocated_game_name(std::string* game_name);
  private:
  const std::string& _internal_game_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_name(const std::string& value);
  std::string* _internal_mutable_game_name();
  public:

  // required .snakes.GamePlayers players = 1;
  bool has_players() const;
  private:
  bool _internal_has_players() const;
  public:
  void clear_players();
  const ::snakes::GamePlayers& players() const;
  PROTOBUF_NODISCARD ::snakes::GamePlayers* release_players();
  ::snakes::GamePlayers* mutable_players();
  void set_allocated_players(::snakes::GamePlayers* players);
  private:
  const ::snakes::GamePlayers& _internal_players() const;
  ::snakes::GamePlayers* _internal_mutable_players();
  public:
  void unsafe_arena_set_allocated_players(
      ::snakes::GamePlayers* players);
  ::snakes::GamePlayers* unsafe_arena_release_players();

  // required .snakes.GameConfig config = 2;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::snakes::GameConfig& config() const;
  PROTOBUF_NODISCARD ::snakes::GameConfig* release_config();
  ::snakes::GameConfig* mutable_config();
  void set_allocated_config(::snakes::GameConfig* config);
  private:
  const ::snakes::GameConfig& _internal_config() const;
  ::snakes::GameConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::snakes::GameConfig* config);
  ::snakes::GameConfig* unsafe_arena_release_config();

  // optional bool can_join = 3 [default = true];
  bool has_can_join() const;
  private:
  bool _internal_has_can_join() const;
  public:
  void clear_can_join();
  bool can_join() const;
  void set_can_join(bool value);
  private:
  bool _internal_can_join() const;
  void _internal_set_can_join(bool value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameAnnouncement)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_name_;
    ::snakes::GamePlayers* players_;
    ::snakes::GameConfig* config_;
    bool can_join_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_PingMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:snakes.GameMessage.PingMsg) */ {
 public:
  inline GameMessage_PingMsg() : GameMessage_PingMsg(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GameMessage_PingMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameMessage_PingMsg(const GameMessage_PingMsg& from);
  GameMessage_PingMsg(GameMessage_PingMsg&& from) noexcept
    : GameMessage_PingMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_PingMsg& operator=(const GameMessage_PingMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_PingMsg& operator=(GameMessage_PingMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameMessage_PingMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameMessage_PingMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_PingMsg*>(
               &_GameMessage_PingMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GameMessage_PingMsg& a, GameMessage_PingMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_PingMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_PingMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameMessage_PingMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameMessage_PingMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GameMessage_PingMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GameMessage_PingMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.PingMsg";
  }
  protected:
  explicit GameMessage_PingMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.PingMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_SteerMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.SteerMsg) */ {
 public:
  inline GameMessage_SteerMsg() : GameMessage_SteerMsg(nullptr) {}
  ~GameMessage_SteerMsg() override;
  explicit PROTOBUF_CONSTEXPR GameMessage_SteerMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameMessage_SteerMsg(const GameMessage_SteerMsg& from);
  GameMessage_SteerMsg(GameMessage_SteerMsg&& from) noexcept
    : GameMessage_SteerMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_SteerMsg& operator=(const GameMessage_SteerMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_SteerMsg& operator=(GameMessage_SteerMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameMessage_SteerMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameMessage_SteerMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_SteerMsg*>(
               &_GameMessage_SteerMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GameMessage_SteerMsg& a, GameMessage_SteerMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_SteerMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_SteerMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameMessage_SteerMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameMessage_SteerMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameMessage_SteerMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameMessage_SteerMsg& from) {
    GameMessage_SteerMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage_SteerMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.SteerMsg";
  }
  protected:
  explicit GameMessage_SteerMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionFieldNumber = 1,
  };
  // required .snakes.Direction direction = 1;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  ::snakes::Direction direction() const;
  void set_direction(::snakes::Direction value);
  private:
  ::snakes::Direction _internal_direction() const;
  void _internal_set_direction(::snakes::Direction value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.SteerMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int direction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_AckMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:snakes.GameMessage.AckMsg) */ {
 public:
  inline GameMessage_AckMsg() : GameMessage_AckMsg(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GameMessage_AckMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameMessage_AckMsg(const GameMessage_AckMsg& from);
  GameMessage_AckMsg(GameMessage_AckMsg&& from) noexcept
    : GameMessage_AckMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_AckMsg& operator=(const GameMessage_AckMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_AckMsg& operator=(GameMessage_AckMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameMessage_AckMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameMessage_AckMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_AckMsg*>(
               &_GameMessage_AckMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GameMessage_AckMsg& a, GameMessage_AckMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_AckMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_AckMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameMessage_AckMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameMessage_AckMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GameMessage_AckMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GameMessage_AckMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.AckMsg";
  }
  protected:
  explicit GameMessage_AckMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.AckMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_StateMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.StateMsg) */ {
 public:
  inline GameMessage_StateMsg() : GameMessage_StateMsg(nullptr) {}
  ~GameMessage_StateMsg() override;
  explicit PROTOBUF_CONSTEXPR GameMessage_StateMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameMessage_StateMsg(const GameMessage_StateMsg& from);
  GameMessage_StateMsg(GameMessage_StateMsg&& from) noexcept
    : GameMessage_StateMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_StateMsg& operator=(const GameMessage_StateMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_StateMsg& operator=(GameMessage_StateMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameMessage_StateMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameMessage_StateMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_StateMsg*>(
               &_GameMessage_StateMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GameMessage_StateMsg& a, GameMessage_StateMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_StateMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_StateMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameMessage_StateMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameMessage_StateMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameMessage_StateMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameMessage_StateMsg& from) {
    GameMessage_StateMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage_StateMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.StateMsg";
  }
  protected:
  explicit GameMessage_StateMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // required .snakes.GameState state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::snakes::GameState& state() const;
  PROTOBUF_NODISCARD ::snakes::GameState* release_state();
  ::snakes::GameState* mutable_state();
  void set_allocated_state(::snakes::GameState* state);
  private:
  const ::snakes::GameState& _internal_state() const;
  ::snakes::GameState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::snakes::GameState* state);
  ::snakes::GameState* unsafe_arena_release_state();

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.StateMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::snakes::GameState* state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_AnnouncementMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.AnnouncementMsg) */ {
 public:
  inline GameMessage_AnnouncementMsg() : GameMessage_AnnouncementMsg(nullptr) {}
  ~GameMessage_AnnouncementMsg() override;
  explicit PROTOBUF_CONSTEXPR GameMessage_AnnouncementMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameMessage_AnnouncementMsg(const GameMessage_AnnouncementMsg& from);
  GameMessage_AnnouncementMsg(GameMessage_AnnouncementMsg&& from) noexcept
    : GameMessage_AnnouncementMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_AnnouncementMsg& operator=(const GameMessage_AnnouncementMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_AnnouncementMsg& operator=(GameMessage_AnnouncementMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameMessage_AnnouncementMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameMessage_AnnouncementMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_AnnouncementMsg*>(
               &_GameMessage_AnnouncementMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GameMessage_AnnouncementMsg& a, GameMessage_AnnouncementMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_AnnouncementMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_AnnouncementMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameMessage_AnnouncementMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameMessage_AnnouncementMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameMessage_AnnouncementMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameMessage_AnnouncementMsg& from) {
    GameMessage_AnnouncementMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage_AnnouncementMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.AnnouncementMsg";
  }
  protected:
  explicit GameMessage_AnnouncementMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGamesFieldNumber = 1,
  };
  // repeated .snakes.GameAnnouncement games = 1;
  int games_size() const;
  private:
  int _internal_games_size() const;
  public:
  void clear_games();
  ::snakes::GameAnnouncement* mutable_games(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameAnnouncement >*
      mutable_games();
  private:
  const ::snakes::GameAnnouncement& _internal_games(int index) const;
  ::snakes::GameAnnouncement* _internal_add_games();
  public:
  const ::snakes::GameAnnouncement& games(int index) const;
  ::snakes::GameAnnouncement* add_games();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameAnnouncement >&
      games() const;

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.AnnouncementMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameAnnouncement > games_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_DiscoverMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:snakes.GameMessage.DiscoverMsg) */ {
 public:
  inline GameMessage_DiscoverMsg() : GameMessage_DiscoverMsg(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GameMessage_DiscoverMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameMessage_DiscoverMsg(const GameMessage_DiscoverMsg& from);
  GameMessage_DiscoverMsg(GameMessage_DiscoverMsg&& from) noexcept
    : GameMessage_DiscoverMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_DiscoverMsg& operator=(const GameMessage_DiscoverMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_DiscoverMsg& operator=(GameMessage_DiscoverMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameMessage_DiscoverMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameMessage_DiscoverMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_DiscoverMsg*>(
               &_GameMessage_DiscoverMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GameMessage_DiscoverMsg& a, GameMessage_DiscoverMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_DiscoverMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_DiscoverMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameMessage_DiscoverMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameMessage_DiscoverMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GameMessage_DiscoverMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GameMessage_DiscoverMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.DiscoverMsg";
  }
  protected:
  explicit GameMessage_DiscoverMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.DiscoverMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_JoinMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.JoinMsg) */ {
 public:
  inline GameMessage_JoinMsg() : GameMessage_JoinMsg(nullptr) {}
  ~GameMessage_JoinMsg() override;
  explicit PROTOBUF_CONSTEXPR GameMessage_JoinMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameMessage_JoinMsg(const GameMessage_JoinMsg& from);
  GameMessage_JoinMsg(GameMessage_JoinMsg&& from) noexcept
    : GameMessage_JoinMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_JoinMsg& operator=(const GameMessage_JoinMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_JoinMsg& operator=(GameMessage_JoinMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameMessage_JoinMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameMessage_JoinMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_JoinMsg*>(
               &_GameMessage_JoinMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GameMessage_JoinMsg& a, GameMessage_JoinMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_JoinMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_JoinMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameMessage_JoinMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameMessage_JoinMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameMessage_JoinMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameMessage_JoinMsg& from) {
    GameMessage_JoinMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage_JoinMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.JoinMsg";
  }
  protected:
  explicit GameMessage_JoinMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 3,
    kGameNameFieldNumber = 4,
    kPlayerTypeFieldNumber = 1,
    kRequestedRoleFieldNumber = 5,
  };
  // required string player_name = 3;
  bool has_player_name() const;
  private:
  bool _internal_has_player_name() const;
  public:
  void clear_player_name();
  const std::string& player_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_name();
  PROTOBUF_NODISCARD std::string* release_player_name();
  void set_allocated_player_name(std::string* player_name);
  private:
  const std::string& _internal_player_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_name(const std::string& value);
  std::string* _internal_mutable_player_name();
  public:

  // required string game_name = 4;
  bool has_game_name() const;
  private:
  bool _internal_has_game_name() const;
  public:
  void clear_game_name();
  const std::string& game_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_name();
  PROTOBUF_NODISCARD std::string* release_game_name();
  void set_allocated_game_name(std::string* game_name);
  private:
  const std::string& _internal_game_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_name(const std::string& value);
  std::string* _internal_mutable_game_name();
  public:

  // optional .snakes.PlayerType player_type = 1 [default = HUMAN];
  bool has_player_type() const;
  private:
  bool _internal_has_player_type() const;
  public:
  void clear_player_type();
  ::snakes::PlayerType player_type() const;
  void set_player_type(::snakes::PlayerType value);
  private:
  ::snakes::PlayerType _internal_player_type() const;
  void _internal_set_player_type(::snakes::PlayerType value);
  public:

  // required .snakes.NodeRole requested_role = 5;
  bool has_requested_role() const;
  private:
  bool _internal_has_requested_role() const;
  public:
  void clear_requested_role();
  ::snakes::NodeRole requested_role() const;
  void set_requested_role(::snakes::NodeRole value);
  private:
  ::snakes::NodeRole _internal_requested_role() const;
  void _internal_set_requested_role(::snakes::NodeRole value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.JoinMsg)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_name_;
    int player_type_;
    int requested_role_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_ErrorMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.ErrorMsg) */ {
 public:
  inline GameMessage_ErrorMsg() : GameMessage_ErrorMsg(nullptr) {}
  ~GameMessage_ErrorMsg() override;
  explicit PROTOBUF_CONSTEXPR GameMessage_ErrorMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameMessage_ErrorMsg(const GameMessage_ErrorMsg& from);
  GameMessage_ErrorMsg(GameMessage_ErrorMsg&& from) noexcept
    : GameMessage_ErrorMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_ErrorMsg& operator=(const GameMessage_ErrorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_ErrorMsg& operator=(GameMessage_ErrorMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameMessage_ErrorMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameMessage_ErrorMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_ErrorMsg*>(
               &_GameMessage_ErrorMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GameMessage_ErrorMsg& a, GameMessage_ErrorMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_ErrorMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_ErrorMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameMessage_ErrorMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameMessage_ErrorMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameMessage_ErrorMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameMessage_ErrorMsg& from) {
    GameMessage_ErrorMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage_ErrorMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.ErrorMsg";
  }
  protected:
  explicit GameMessage_ErrorMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 1,
  };
  // required string error_message = 1;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.ErrorMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_RoleChangeMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.RoleChangeMsg) */ {
 public:
  inline GameMessage_RoleChangeMsg() : GameMessage_RoleChangeMsg(nullptr) {}
  ~GameMessage_RoleChangeMsg() override;
  explicit PROTOBUF_CONSTEXPR GameMessage_RoleChangeMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameMessage_RoleChangeMsg(const GameMessage_RoleChangeMsg& from);
  GameMessage_RoleChangeMsg(GameMessage_RoleChangeMsg&& from) noexcept
    : GameMessage_RoleChangeMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_RoleChangeMsg& operator=(const GameMessage_RoleChangeMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_RoleChangeMsg& operator=(GameMessage_RoleChangeMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameMessage_RoleChangeMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameMessage_RoleChangeMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_RoleChangeMsg*>(
               &_GameMessage_RoleChangeMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GameMessage_RoleChangeMsg& a, GameMessage_RoleChangeMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_RoleChangeMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_RoleChangeMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameMessage_RoleChangeMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameMessage_RoleChangeMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameMessage_RoleChangeMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameMessage_RoleChangeMsg& from) {
    GameMessage_RoleChangeMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage_RoleChangeMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.RoleChangeMsg";
  }
  protected:
  explicit GameMessage_RoleChangeMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderRoleFieldNumber = 1,
    kReceiverRoleFieldNumber = 2,
  };
  // optional .snakes.NodeRole sender_role = 1;
  bool has_sender_role() const;
  private:
  bool _internal_has_sender_role() const;
  public:
  void clear_sender_role();
  ::snakes::NodeRole sender_role() const;
  void set_sender_role(::snakes::NodeRole value);
  private:
  ::snakes::NodeRole _internal_sender_role() const;
  void _internal_set_sender_role(::snakes::NodeRole value);
  public:

  // optional .snakes.NodeRole receiver_role = 2;
  bool has_receiver_role() const;
  private:
  bool _internal_has_receiver_role() const;
  public:
  void clear_receiver_role();
  ::snakes::NodeRole receiver_role() const;
  void set_receiver_role(::snakes::NodeRole value);
  private:
  ::snakes::NodeRole _internal_receiver_role() const;
  void _internal_set_receiver_role(::snakes::NodeRole value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.RoleChangeMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int sender_role_;
    int receiver_role_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage) */ {
 public:
  inline GameMessage() : GameMessage(nullptr) {}
  ~GameMessage() override;
  explicit PROTOBUF_CONSTEXPR GameMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameMessage(const GameMessage& from);
  GameMessage(GameMessage&& from) noexcept
    : GameMessage() {
    *this = ::std::move(from);
  }

  inline GameMessage& operator=(const GameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage& operator=(GameMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameMessage& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kPing = 2,
    kSteer = 3,
    kAck = 4,
    kState = 5,
    kAnnouncement = 6,
    kJoin = 7,
    kError = 8,
    kRoleChange = 9,
    kDiscover = 12,
    TYPE_NOT_SET = 0,
  };

  static inline const GameMessage* internal_default_instance() {
    return reinterpret_cast<const GameMessage*>(
               &_GameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GameMessage& a, GameMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameMessage& from) {
    GameMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage";
  }
  protected:
  explicit GameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GameMessage_PingMsg PingMsg;
  typedef GameMessage_SteerMsg SteerMsg;
  typedef GameMessage_AckMsg AckMsg;
  typedef GameMessage_StateMsg StateMsg;
  typedef GameMessage_AnnouncementMsg AnnouncementMsg;
  typedef GameMessage_DiscoverMsg DiscoverMsg;
  typedef GameMessage_JoinMsg JoinMsg;
  typedef GameMessage_ErrorMsg ErrorMsg;
  typedef GameMessage_RoleChangeMsg RoleChangeMsg;

  // accessors -------------------------------------------------------

  enum : int {
    kMsgSeqFieldNumber = 1,
    kSenderIdFieldNumber = 10,
    kReceiverIdFieldNumber = 11,
    kPingFieldNumber = 2,
    kSteerFieldNumber = 3,
    kAckFieldNumber = 4,
    kStateFieldNumber = 5,
    kAnnouncementFieldNumber = 6,
    kJoinFieldNumber = 7,
    kErrorFieldNumber = 8,
    kRoleChangeFieldNumber = 9,
    kDiscoverFieldNumber = 12,
  };
  // required int64 msg_seq = 1;
  bool has_msg_seq() const;
  private:
  bool _internal_has_msg_seq() const;
  public:
  void clear_msg_seq();
  int64_t msg_seq() const;
  void set_msg_seq(int64_t value);
  private:
  int64_t _internal_msg_seq() const;
  void _internal_set_msg_seq(int64_t value);
  public:

  // optional int32 sender_id = 10;
  bool has_sender_id() const;
  private:
  bool _internal_has_sender_id() const;
  public:
  void clear_sender_id();
  int32_t sender_id() const;
  void set_sender_id(int32_t value);
  private:
  int32_t _internal_sender_id() const;
  void _internal_set_sender_id(int32_t value);
  public:

  // optional int32 receiver_id = 11;
  bool has_receiver_id() const;
  private:
  bool _internal_has_receiver_id() const;
  public:
  void clear_receiver_id();
  int32_t receiver_id() const;
  void set_receiver_id(int32_t value);
  private:
  int32_t _internal_receiver_id() const;
  void _internal_set_receiver_id(int32_t value);
  public:

  // .snakes.GameMessage.PingMsg ping = 2;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;
  public:
  void clear_ping();
  const ::snakes::GameMessage_PingMsg& ping() const;
  PROTOBUF_NODISCARD ::snakes::GameMessage_PingMsg* release_ping();
  ::snakes::GameMessage_PingMsg* mutable_ping();
  void set_allocated_ping(::snakes::GameMessage_PingMsg* ping);
  private:
  const ::snakes::GameMessage_PingMsg& _internal_ping() const;
  ::snakes::GameMessage_PingMsg* _internal_mutable_ping();
  public:
  void unsafe_arena_set_allocated_ping(
      ::snakes::GameMessage_PingMsg* ping);
  ::snakes::GameMessage_PingMsg* unsafe_arena_release_ping();

  // .snakes.GameMessage.SteerMsg steer = 3;
  bool has_steer() const;
  private:
  bool _internal_has_steer() const;
  public:
  void clear_steer();
  const ::snakes::GameMessage_SteerMsg& steer() const;
  PROTOBUF_NODISCARD ::snakes::GameMessage_SteerMsg* release_steer();
  ::snakes::GameMessage_SteerMsg* mutable_steer();
  void set_allocated_steer(::snakes::GameMessage_SteerMsg* steer);
  private:
  const ::snakes::GameMessage_SteerMsg& _internal_steer() const;
  ::snakes::GameMessage_SteerMsg* _internal_mutable_steer();
  public:
  void unsafe_arena_set_allocated_steer(
      ::snakes::GameMessage_SteerMsg* steer);
  ::snakes::GameMessage_SteerMsg* unsafe_arena_release_steer();

  // .snakes.GameMessage.AckMsg ack = 4;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  const ::snakes::GameMessage_AckMsg& ack() const;
  PROTOBUF_NODISCARD ::snakes::GameMessage_AckMsg* release_ack();
  ::snakes::GameMessage_AckMsg* mutable_ack();
  void set_allocated_ack(::snakes::GameMessage_AckMsg* ack);
  private:
  const ::snakes::GameMessage_AckMsg& _internal_ack() const;
  ::snakes::GameMessage_AckMsg* _internal_mutable_ack();
  public:
  void unsafe_arena_set_allocated_ack(
      ::snakes::GameMessage_AckMsg* ack);
  ::snakes::GameMessage_AckMsg* unsafe_arena_release_ack();

  // .snakes.GameMessage.StateMsg state = 5;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::snakes::GameMessage_StateMsg& state() const;
  PROTOBUF_NODISCARD ::snakes::GameMessage_StateMsg* release_state();
  ::snakes::GameMessage_StateMsg* mutable_state();
  void set_allocated_state(::snakes::GameMessage_StateMsg* state);
  private:
  const ::snakes::GameMessage_StateMsg& _internal_state() const;
  ::snakes::GameMessage_StateMsg* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::snakes::GameMessage_StateMsg* state);
  ::snakes::GameMessage_StateMsg* unsafe_arena_release_state();

  // .snakes.GameMessage.AnnouncementMsg announcement = 6;
  bool has_announcement() const;
  private:
  bool _internal_has_announcement() const;
  public:
  void clear_announcement();
  const ::snakes::GameMessage_AnnouncementMsg& announcement() const;
  PROTOBUF_NODISCARD ::snakes::GameMessage_AnnouncementMsg* release_announcement();
  ::snakes::GameMessage_AnnouncementMsg* mutable_announcement();
  void set_allocated_announcement(::snakes::GameMessage_AnnouncementMsg* announcement);
  private:
  const ::snakes::GameMessage_AnnouncementMsg& _internal_announcement() const;
  ::snakes::GameMessage_AnnouncementMsg* _internal_mutable_announcement();
  public:
  void unsafe_arena_set_allocated_announcement(
      ::snakes::GameMessage_AnnouncementMsg* announcement);
  ::snakes::GameMessage_AnnouncementMsg* unsafe_arena_release_announcement();

  // .snakes.GameMessage.JoinMsg join = 7;
  bool has_join() const;
  private:
  bool _internal_has_join() const;
  public:
  void clear_join();
  const ::snakes::GameMessage_JoinMsg& join() const;
  PROTOBUF_NODISCARD ::snakes::GameMessage_JoinMsg* release_join();
  ::snakes::GameMessage_JoinMsg* mutable_join();
  void set_allocated_join(::snakes::GameMessage_JoinMsg* join);
  private:
  const ::snakes::GameMessage_JoinMsg& _internal_join() const;
  ::snakes::GameMessage_JoinMsg* _internal_mutable_join();
  public:
  void unsafe_arena_set_allocated_join(
      ::snakes::GameMessage_JoinMsg* join);
  ::snakes::GameMessage_JoinMsg* unsafe_arena_release_join();

  // .snakes.GameMessage.ErrorMsg error = 8;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::snakes::GameMessage_ErrorMsg& error() const;
  PROTOBUF_NODISCARD ::snakes::GameMessage_ErrorMsg* release_error();
  ::snakes::GameMessage_ErrorMsg* mutable_error();
  void set_allocated_error(::snakes::GameMessage_ErrorMsg* error);
  private:
  const ::snakes::GameMessage_ErrorMsg& _internal_error() const;
  ::snakes::GameMessage_ErrorMsg* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::snakes::GameMessage_ErrorMsg* error);
  ::snakes::GameMessage_ErrorMsg* unsafe_arena_release_error();

  // .snakes.GameMessage.RoleChangeMsg role_change = 9;
  bool has_role_change() const;
  private:
  bool _internal_has_role_change() const;
  public:
  void clear_role_change();
  const ::snakes::GameMessage_RoleChangeMsg& role_change() const;
  PROTOBUF_NODISCARD ::snakes::GameMessage_RoleChangeMsg* release_role_change();
  ::snakes::GameMessage_RoleChangeMsg* mutable_role_change();
  void set_allocated_role_change(::snakes::GameMessage_RoleChangeMsg* role_change);
  private:
  const ::snakes::GameMessage_RoleChangeMsg& _internal_role_change() const;
  ::snakes::GameMessage_RoleChangeMsg* _internal_mutable_role_change();
  public:
  void unsafe_arena_set_allocated_role_change(
      ::snakes::GameMessage_RoleChangeMsg* role_change);
  ::snakes::GameMessage_RoleChangeMsg* unsafe_arena_release_role_change();

  // .snakes.GameMessage.DiscoverMsg discover = 12;
  bool has_discover() const;
  private:
  bool _internal_has_discover() const;
  public:
  void clear_discover();
  const ::snakes::GameMessage_DiscoverMsg& discover() const;
  PROTOBUF_NODISCARD ::snakes::GameMessage_DiscoverMsg* release_discover();
  ::snakes::GameMessage_DiscoverMsg* mutable_discover();
  void set_allocated_discover(::snakes::GameMessage_DiscoverMsg* discover);
  private:
  const ::snakes::GameMessage_DiscoverMsg& _internal_discover() const;
  ::snakes::GameMessage_DiscoverMsg* _internal_mutable_discover();
  public:
  void unsafe_arena_set_allocated_discover(
      ::snakes::GameMessage_DiscoverMsg* discover);
  ::snakes::GameMessage_DiscoverMsg* unsafe_arena_release_discover();

  void clear_Type();
  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:snakes.GameMessage)
 private:
  class _Internal;
  void set_has_ping();
  void set_has_steer();
  void set_has_ack();
  void set_has_state();
  void set_has_announcement();
  void set_has_join();
  void set_has_error();
  void set_has_role_change();
  void set_has_discover();

  inline bool has_Type() const;
  inline void clear_has_Type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t msg_seq_;
    int32_t sender_id_;
    int32_t receiver_id_;
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::snakes::GameMessage_PingMsg* ping_;
      ::snakes::GameMessage_SteerMsg* steer_;
      ::snakes::GameMessage_AckMsg* ack_;
      ::snakes::GameMessage_StateMsg* state_;
      ::snakes::GameMessage_AnnouncementMsg* announcement_;
      ::snakes::GameMessage_JoinMsg* join_;
      ::snakes::GameMessage_ErrorMsg* error_;
      ::snakes::GameMessage_RoleChangeMsg* role_change_;
      ::snakes::GameMessage_DiscoverMsg* discover_;
    } Type_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_snakes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GamePlayer

// required string name = 1;
inline bool GamePlayer::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GamePlayer::has_name() const {
  return _internal_has_name();
}
inline void GamePlayer::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GamePlayer::name() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GamePlayer::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.name)
}
inline std::string* GamePlayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:snakes.GamePlayer.name)
  return _s;
}
inline const std::string& GamePlayer::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GamePlayer::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GamePlayer::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GamePlayer::release_name() {
  // @@protoc_insertion_point(field_release:snakes.GamePlayer.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GamePlayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:snakes.GamePlayer.name)
}

// required int32 id = 2;
inline bool GamePlayer::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GamePlayer::has_id() const {
  return _internal_has_id();
}
inline void GamePlayer::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t GamePlayer::_internal_id() const {
  return _impl_.id_;
}
inline int32_t GamePlayer::id() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.id)
  return _internal_id();
}
inline void GamePlayer::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.id_ = value;
}
inline void GamePlayer::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.id)
}

// optional string ip_address = 3;
inline bool GamePlayer::_internal_has_ip_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GamePlayer::has_ip_address() const {
  return _internal_has_ip_address();
}
inline void GamePlayer::clear_ip_address() {
  _impl_.ip_address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GamePlayer::ip_address() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GamePlayer::set_ip_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.ip_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.ip_address)
}
inline std::string* GamePlayer::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:snakes.GamePlayer.ip_address)
  return _s;
}
inline const std::string& GamePlayer::_internal_ip_address() const {
  return _impl_.ip_address_.Get();
}
inline void GamePlayer::_internal_set_ip_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ip_address_.Set(value, GetArenaForAllocation());
}
inline std::string* GamePlayer::_internal_mutable_ip_address() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ip_address_.Mutable(GetArenaForAllocation());
}
inline std::string* GamePlayer::release_ip_address() {
  // @@protoc_insertion_point(field_release:snakes.GamePlayer.ip_address)
  if (!_internal_has_ip_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.ip_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_address_.IsDefault()) {
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GamePlayer::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ip_address_.SetAllocated(ip_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_address_.IsDefault()) {
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:snakes.GamePlayer.ip_address)
}

// optional int32 port = 4;
inline bool GamePlayer::_internal_has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GamePlayer::has_port() const {
  return _internal_has_port();
}
inline void GamePlayer::clear_port() {
  _impl_.port_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t GamePlayer::_internal_port() const {
  return _impl_.port_;
}
inline int32_t GamePlayer::port() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.port)
  return _internal_port();
}
inline void GamePlayer::_internal_set_port(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.port_ = value;
}
inline void GamePlayer::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.port)
}

// required .snakes.NodeRole role = 5;
inline bool GamePlayer::_internal_has_role() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GamePlayer::has_role() const {
  return _internal_has_role();
}
inline void GamePlayer::clear_role() {
  _impl_.role_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::snakes::NodeRole GamePlayer::_internal_role() const {
  return static_cast< ::snakes::NodeRole >(_impl_.role_);
}
inline ::snakes::NodeRole GamePlayer::role() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.role)
  return _internal_role();
}
inline void GamePlayer::_internal_set_role(::snakes::NodeRole value) {
  assert(::snakes::NodeRole_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.role_ = value;
}
inline void GamePlayer::set_role(::snakes::NodeRole value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.role)
}

// optional .snakes.PlayerType type = 6 [default = HUMAN];
inline bool GamePlayer::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GamePlayer::has_type() const {
  return _internal_has_type();
}
inline void GamePlayer::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::snakes::PlayerType GamePlayer::_internal_type() const {
  return static_cast< ::snakes::PlayerType >(_impl_.type_);
}
inline ::snakes::PlayerType GamePlayer::type() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.type)
  return _internal_type();
}
inline void GamePlayer::_internal_set_type(::snakes::PlayerType value) {
  assert(::snakes::PlayerType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.type_ = value;
}
inline void GamePlayer::set_type(::snakes::PlayerType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.type)
}

// required int32 score = 7;
inline bool GamePlayer::_internal_has_score() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GamePlayer::has_score() const {
  return _internal_has_score();
}
inline void GamePlayer::clear_score() {
  _impl_.score_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t GamePlayer::_internal_score() const {
  return _impl_.score_;
}
inline int32_t GamePlayer::score() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.score)
  return _internal_score();
}
inline void GamePlayer::_internal_set_score(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.score_ = value;
}
inline void GamePlayer::set_score(int32_t value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.score)
}

// -------------------------------------------------------------------

// GameConfig

// optional int32 width = 1 [default = 40];
inline bool GameConfig::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameConfig::has_width() const {
  return _internal_has_width();
}
inline void GameConfig::clear_width() {
  _impl_.width_ = 40;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t GameConfig::_internal_width() const {
  return _impl_.width_;
}
inline int32_t GameConfig::width() const {
  // @@protoc_insertion_point(field_get:snakes.GameConfig.width)
  return _internal_width();
}
inline void GameConfig::_internal_set_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.width_ = value;
}
inline void GameConfig::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:snakes.GameConfig.width)
}

// optional int32 height = 2 [default = 30];
inline bool GameConfig::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameConfig::has_height() const {
  return _internal_has_height();
}
inline void GameConfig::clear_height() {
  _impl_.height_ = 30;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t GameConfig::_internal_height() const {
  return _impl_.height_;
}
inline int32_t GameConfig::height() const {
  // @@protoc_insertion_point(field_get:snakes.GameConfig.height)
  return _internal_height();
}
inline void GameConfig::_internal_set_height(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.height_ = value;
}
inline void GameConfig::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:snakes.GameConfig.height)
}

// optional int32 food_static = 3 [default = 1];
inline bool GameConfig::_internal_has_food_static() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GameConfig::has_food_static() const {
  return _internal_has_food_static();
}
inline void GameConfig::clear_food_static() {
  _impl_.food_static_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t GameConfig::_internal_food_static() const {
  return _impl_.food_static_;
}
inline int32_t GameConfig::food_static() const {
  // @@protoc_insertion_point(field_get:snakes.GameConfig.food_static)
  return _internal_food_static();
}
inline void GameConfig::_internal_set_food_static(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.food_static_ = value;
}
inline void GameConfig::set_food_static(int32_t value) {
  _internal_set_food_static(value);
  // @@protoc_insertion_point(field_set:snakes.GameConfig.food_static)
}

// optional int32 state_delay_ms = 5 [default = 1000];
inline bool GameConfig::_internal_has_state_delay_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GameConfig::has_state_delay_ms() const {
  return _internal_has_state_delay_ms();
}
inline void GameConfig::clear_state_delay_ms() {
  _impl_.state_delay_ms_ = 1000;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t GameConfig::_internal_state_delay_ms() const {
  return _impl_.state_delay_ms_;
}
inline int32_t GameConfig::state_delay_ms() const {
  // @@protoc_insertion_point(field_get:snakes.GameConfig.state_delay_ms)
  return _internal_state_delay_ms();
}
inline void GameConfig::_internal_set_state_delay_ms(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.state_delay_ms_ = value;
}
inline void GameConfig::set_state_delay_ms(int32_t value) {
  _internal_set_state_delay_ms(value);
  // @@protoc_insertion_point(field_set:snakes.GameConfig.state_delay_ms)
}

// -------------------------------------------------------------------

// GamePlayers

// repeated .snakes.GamePlayer players = 1;
inline int GamePlayers::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int GamePlayers::players_size() const {
  return _internal_players_size();
}
inline void GamePlayers::clear_players() {
  _impl_.players_.Clear();
}
inline ::snakes::GamePlayer* GamePlayers::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:snakes.GamePlayers.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GamePlayer >*
GamePlayers::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:snakes.GamePlayers.players)
  return &_impl_.players_;
}
inline const ::snakes::GamePlayer& GamePlayers::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::snakes::GamePlayer& GamePlayers::players(int index) const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayers.players)
  return _internal_players(index);
}
inline ::snakes::GamePlayer* GamePlayers::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::snakes::GamePlayer* GamePlayers::add_players() {
  ::snakes::GamePlayer* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:snakes.GamePlayers.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GamePlayer >&
GamePlayers::players() const {
  // @@protoc_insertion_point(field_list:snakes.GamePlayers.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// GameState_Coord

// optional sint32 x = 1 [default = 0];
inline bool GameState_Coord::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameState_Coord::has_x() const {
  return _internal_has_x();
}
inline void GameState_Coord::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t GameState_Coord::_internal_x() const {
  return _impl_.x_;
}
inline int32_t GameState_Coord::x() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Coord.x)
  return _internal_x();
}
inline void GameState_Coord::_internal_set_x(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void GameState_Coord::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:snakes.GameState.Coord.x)
}

// optional sint32 y = 2 [default = 0];
inline bool GameState_Coord::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameState_Coord::has_y() const {
  return _internal_has_y();
}
inline void GameState_Coord::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t GameState_Coord::_internal_y() const {
  return _impl_.y_;
}
inline int32_t GameState_Coord::y() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Coord.y)
  return _internal_y();
}
inline void GameState_Coord::_internal_set_y(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void GameState_Coord::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:snakes.GameState.Coord.y)
}

// -------------------------------------------------------------------

// GameState_Snake

// required int32 player_id = 1;
inline bool GameState_Snake::_internal_has_player_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameState_Snake::has_player_id() const {
  return _internal_has_player_id();
}
inline void GameState_Snake::clear_player_id() {
  _impl_.player_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t GameState_Snake::_internal_player_id() const {
  return _impl_.player_id_;
}
inline int32_t GameState_Snake::player_id() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Snake.player_id)
  return _internal_player_id();
}
inline void GameState_Snake::_internal_set_player_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.player_id_ = value;
}
inline void GameState_Snake::set_player_id(int32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:snakes.GameState.Snake.player_id)
}

// repeated .snakes.GameState.Coord points = 2;
inline int GameState_Snake::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int GameState_Snake::points_size() const {
  return _internal_points_size();
}
inline void GameState_Snake::clear_points() {
  _impl_.points_.Clear();
}
inline ::snakes::GameState_Coord* GameState_Snake::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:snakes.GameState.Snake.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord >*
GameState_Snake::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:snakes.GameState.Snake.points)
  return &_impl_.points_;
}
inline const ::snakes::GameState_Coord& GameState_Snake::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::snakes::GameState_Coord& GameState_Snake::points(int index) const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Snake.points)
  return _internal_points(index);
}
inline ::snakes::GameState_Coord* GameState_Snake::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::snakes::GameState_Coord* GameState_Snake::add_points() {
  ::snakes::GameState_Coord* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:snakes.GameState.Snake.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord >&
GameState_Snake::points() const {
  // @@protoc_insertion_point(field_list:snakes.GameState.Snake.points)
  return _impl_.points_;
}

// required .snakes.GameState.Snake.SnakeState state = 3 [default = ALIVE];
inline bool GameState_Snake::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameState_Snake::has_state() const {
  return _internal_has_state();
}
inline void GameState_Snake::clear_state() {
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::snakes::GameState_Snake_SnakeState GameState_Snake::_internal_state() const {
  return static_cast< ::snakes::GameState_Snake_SnakeState >(_impl_.state_);
}
inline ::snakes::GameState_Snake_SnakeState GameState_Snake::state() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Snake.state)
  return _internal_state();
}
inline void GameState_Snake::_internal_set_state(::snakes::GameState_Snake_SnakeState value) {
  assert(::snakes::GameState_Snake_SnakeState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.state_ = value;
}
inline void GameState_Snake::set_state(::snakes::GameState_Snake_SnakeState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:snakes.GameState.Snake.state)
}

// required .snakes.Direction head_direction = 4;
inline bool GameState_Snake::_internal_has_head_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GameState_Snake::has_head_direction() const {
  return _internal_has_head_direction();
}
inline void GameState_Snake::clear_head_direction() {
  _impl_.head_direction_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::snakes::Direction GameState_Snake::_internal_head_direction() const {
  return static_cast< ::snakes::Direction >(_impl_.head_direction_);
}
inline ::snakes::Direction GameState_Snake::head_direction() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Snake.head_direction)
  return _internal_head_direction();
}
inline void GameState_Snake::_internal_set_head_direction(::snakes::Direction value) {
  assert(::snakes::Direction_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.head_direction_ = value;
}
inline void GameState_Snake::set_head_direction(::snakes::Direction value) {
  _internal_set_head_direction(value);
  // @@protoc_insertion_point(field_set:snakes.GameState.Snake.head_direction)
}

// -------------------------------------------------------------------

// GameState

// required int32 state_order = 1;
inline bool GameState::_internal_has_state_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameState::has_state_order() const {
  return _internal_has_state_order();
}
inline void GameState::clear_state_order() {
  _impl_.state_order_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t GameState::_internal_state_order() const {
  return _impl_.state_order_;
}
inline int32_t GameState::state_order() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.state_order)
  return _internal_state_order();
}
inline void GameState::_internal_set_state_order(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.state_order_ = value;
}
inline void GameState::set_state_order(int32_t value) {
  _internal_set_state_order(value);
  // @@protoc_insertion_point(field_set:snakes.GameState.state_order)
}

// repeated .snakes.GameState.Snake snakes = 2;
inline int GameState::_internal_snakes_size() const {
  return _impl_.snakes_.size();
}
inline int GameState::snakes_size() const {
  return _internal_snakes_size();
}
inline void GameState::clear_snakes() {
  _impl_.snakes_.Clear();
}
inline ::snakes::GameState_Snake* GameState::mutable_snakes(int index) {
  // @@protoc_insertion_point(field_mutable:snakes.GameState.snakes)
  return _impl_.snakes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Snake >*
GameState::mutable_snakes() {
  // @@protoc_insertion_point(field_mutable_list:snakes.GameState.snakes)
  return &_impl_.snakes_;
}
inline const ::snakes::GameState_Snake& GameState::_internal_snakes(int index) const {
  return _impl_.snakes_.Get(index);
}
inline const ::snakes::GameState_Snake& GameState::snakes(int index) const {
  // @@protoc_insertion_point(field_get:snakes.GameState.snakes)
  return _internal_snakes(index);
}
inline ::snakes::GameState_Snake* GameState::_internal_add_snakes() {
  return _impl_.snakes_.Add();
}
inline ::snakes::GameState_Snake* GameState::add_snakes() {
  ::snakes::GameState_Snake* _add = _internal_add_snakes();
  // @@protoc_insertion_point(field_add:snakes.GameState.snakes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Snake >&
GameState::snakes() const {
  // @@protoc_insertion_point(field_list:snakes.GameState.snakes)
  return _impl_.snakes_;
}

// repeated .snakes.GameState.Coord foods = 3;
inline int GameState::_internal_foods_size() const {
  return _impl_.foods_.size();
}
inline int GameState::foods_size() const {
  return _internal_foods_size();
}
inline void GameState::clear_foods() {
  _impl_.foods_.Clear();
}
inline ::snakes::GameState_Coord* GameState::mutable_foods(int index) {
  // @@protoc_insertion_point(field_mutable:snakes.GameState.foods)
  return _impl_.foods_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord >*
GameState::mutable_foods() {
  // @@protoc_insertion_point(field_mutable_list:snakes.GameState.foods)
  return &_impl_.foods_;
}
inline const ::snakes::GameState_Coord& GameState::_internal_foods(int index) const {
  return _impl_.foods_.Get(index);
}
inline const ::snakes::GameState_Coord& GameState::foods(int index) const {
  // @@protoc_insertion_point(field_get:snakes.GameState.foods)
  return _internal_foods(index);
}
inline ::snakes::GameState_Coord* GameState::_internal_add_foods() {
  return _impl_.foods_.Add();
}
inline ::snakes::GameState_Coord* GameState::add_foods() {
  ::snakes::GameState_Coord* _add = _internal_add_foods();
  // @@protoc_insertion_point(field_add:snakes.GameState.foods)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord >&
GameState::foods() const {
  // @@protoc_insertion_point(field_list:snakes.GameState.foods)
  return _impl_.foods_;
}

// required .snakes.GamePlayers players = 4;
inline bool GameState::_internal_has_players() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.players_ != nullptr);
  return value;
}
inline bool GameState::has_players() const {
  return _internal_has_players();
}
inline void GameState::clear_players() {
  if (_impl_.players_ != nullptr) _impl_.players_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::snakes::GamePlayers& GameState::_internal_players() const {
  const ::snakes::GamePlayers* p = _impl_.players_;
  return p != nullptr ? *p : reinterpret_cast<const ::snakes::GamePlayers&>(
      ::snakes::_GamePlayers_default_instance_);
}
inline const ::snakes::GamePlayers& GameState::players() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.players)
  return _internal_players();
}
inline void GameState::unsafe_arena_set_allocated_players(
    ::snakes::GamePlayers* players) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.players_);
  }
  _impl_.players_ = players;
  if (players) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameState.players)
}
inline ::snakes::GamePlayers* GameState::release_players() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::snakes::GamePlayers* temp = _impl_.players_;
  _impl_.players_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::snakes::GamePlayers* GameState::unsafe_arena_release_players() {
  // @@protoc_insertion_point(field_release:snakes.GameState.players)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::snakes::GamePlayers* temp = _impl_.players_;
  _impl_.players_ = nullptr;
  return temp;
}
inline ::snakes::GamePlayers* GameState::_internal_mutable_players() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.players_ == nullptr) {
    auto* p = CreateMaybeMessage<::snakes::GamePlayers>(GetArenaForAllocation());
    _impl_.players_ = p;
  }
  return _impl_.players_;
}
inline ::snakes::GamePlayers* GameState::mutable_players() {
  ::snakes::GamePlayers* _msg = _internal_mutable_players();
  // @@protoc_insertion_point(field_mutable:snakes.GameState.players)
  return _msg;
}
inline void GameState::set_allocated_players(::snakes::GamePlayers* players) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.players_;
  }
  if (players) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(players);
    if (message_arena != submessage_arena) {
      players = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, players, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.players_ = players;
  // @@protoc_insertion_point(field_set_allocated:snakes.GameState.players)
}

// -------------------------------------------------------------------

// GameAnnouncement

// required .snakes.GamePlayers players = 1;
inline bool GameAnnouncement::_internal_has_players() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.players_ != nullptr);
  return value;
}
inline bool GameAnnouncement::has_players() const {
  return _internal_has_players();
}
inline void GameAnnouncement::clear_players() {
  if (_impl_.players_ != nullptr) _impl_.players_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::snakes::GamePlayers& GameAnnouncement::_internal_players() const {
  const ::snakes::GamePlayers* p = _impl_.players_;
  return p != nullptr ? *p : reinterpret_cast<const ::snakes::GamePlayers&>(
      ::snakes::_GamePlayers_default_instance_);
}
inline const ::snakes::GamePlayers& GameAnnouncement::players() const {
  // @@protoc_insertion_point(field_get:snakes.GameAnnouncement.players)
  return _internal_players();
}
inline void GameAnnouncement::unsafe_arena_set_allocated_players(
    ::snakes::GamePlayers* players) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.players_);
  }
  _impl_.players_ = players;
  if (players) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameAnnouncement.players)
}
inline ::snakes::GamePlayers* GameAnnouncement::release_players() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::snakes::GamePlayers* temp = _impl_.players_;
  _impl_.players_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::snakes::GamePlayers* GameAnnouncement::unsafe_arena_release_players() {
  // @@protoc_insertion_point(field_release:snakes.GameAnnouncement.players)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::snakes::GamePlayers* temp = _impl_.players_;
  _impl_.players_ = nullptr;
  return temp;
}
inline ::snakes::GamePlayers* GameAnnouncement::_internal_mutable_players() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.players_ == nullptr) {
    auto* p = CreateMaybeMessage<::snakes::GamePlayers>(GetArenaForAllocation());
    _impl_.players_ = p;
  }
  return _impl_.players_;
}
inline ::snakes::GamePlayers* GameAnnouncement::mutable_players() {
  ::snakes::GamePlayers* _msg = _internal_mutable_players();
  // @@protoc_insertion_point(field_mutable:snakes.GameAnnouncement.players)
  return _msg;
}
inline void GameAnnouncement::set_allocated_players(::snakes::GamePlayers* players) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.players_;
  }
  if (players) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(players);
    if (message_arena != submessage_arena) {
      players = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, players, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.players_ = players;
  // @@protoc_insertion_point(field_set_allocated:snakes.GameAnnouncement.players)
}

// required .snakes.GameConfig config = 2;
inline bool GameAnnouncement::_internal_has_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.config_ != nullptr);
  return value;
}
inline bool GameAnnouncement::has_config() const {
  return _internal_has_config();
}
inline void GameAnnouncement::clear_config() {
  if (_impl_.config_ != nullptr) _impl_.config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::snakes::GameConfig& GameAnnouncement::_internal_config() const {
  const ::snakes::GameConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::snakes::GameConfig&>(
      ::snakes::_GameConfig_default_instance_);
}
inline const ::snakes::GameConfig& GameAnnouncement::config() const {
  // @@protoc_insertion_point(field_get:snakes.GameAnnouncement.config)
  return _internal_config();
}
inline void GameAnnouncement::unsafe_arena_set_allocated_config(
    ::snakes::GameConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  if (config) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameAnnouncement.config)
}
inline ::snakes::GameConfig* GameAnnouncement::release_config() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::snakes::GameConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::snakes::GameConfig* GameAnnouncement::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:snakes.GameAnnouncement.config)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::snakes::GameConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::snakes::GameConfig* GameAnnouncement::_internal_mutable_config() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::snakes::GameConfig>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::snakes::GameConfig* GameAnnouncement::mutable_config() {
  ::snakes::GameConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:snakes.GameAnnouncement.config)
  return _msg;
}
inline void GameAnnouncement::set_allocated_config(::snakes::GameConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:snakes.GameAnnouncement.config)
}

// optional bool can_join = 3 [default = true];
inline bool GameAnnouncement::_internal_has_can_join() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GameAnnouncement::has_can_join() const {
  return _internal_has_can_join();
}
inline void GameAnnouncement::clear_can_join() {
  _impl_.can_join_ = true;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool GameAnnouncement::_internal_can_join() const {
  return _impl_.can_join_;
}
inline bool GameAnnouncement::can_join() const {
  // @@protoc_insertion_point(field_get:snakes.GameAnnouncement.can_join)
  return _internal_can_join();
}
inline void GameAnnouncement::_internal_set_can_join(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.can_join_ = value;
}
inline void GameAnnouncement::set_can_join(bool value) {
  _internal_set_can_join(value);
  // @@protoc_insertion_point(field_set:snakes.GameAnnouncement.can_join)
}

// required string game_name = 4;
inline bool GameAnnouncement::_internal_has_game_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameAnnouncement::has_game_name() const {
  return _internal_has_game_name();
}
inline void GameAnnouncement::clear_game_name() {
  _impl_.game_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GameAnnouncement::game_name() const {
  // @@protoc_insertion_point(field_get:snakes.GameAnnouncement.game_name)
  return _internal_game_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameAnnouncement::set_game_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.game_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:snakes.GameAnnouncement.game_name)
}
inline std::string* GameAnnouncement::mutable_game_name() {
  std::string* _s = _internal_mutable_game_name();
  // @@protoc_insertion_point(field_mutable:snakes.GameAnnouncement.game_name)
  return _s;
}
inline const std::string& GameAnnouncement::_internal_game_name() const {
  return _impl_.game_name_.Get();
}
inline void GameAnnouncement::_internal_set_game_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.game_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GameAnnouncement::_internal_mutable_game_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.game_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GameAnnouncement::release_game_name() {
  // @@protoc_insertion_point(field_release:snakes.GameAnnouncement.game_name)
  if (!_internal_has_game_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.game_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_name_.IsDefault()) {
    _impl_.game_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GameAnnouncement::set_allocated_game_name(std::string* game_name) {
  if (game_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.game_name_.SetAllocated(game_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_name_.IsDefault()) {
    _impl_.game_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:snakes.GameAnnouncement.game_name)
}

// -------------------------------------------------------------------

// GameMessage_PingMsg

// -------------------------------------------------------------------

// GameMessage_SteerMsg

// required .snakes.Direction direction = 1;
inline bool GameMessage_SteerMsg::_internal_has_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameMessage_SteerMsg::has_direction() const {
  return _internal_has_direction();
}
inline void GameMessage_SteerMsg::clear_direction() {
  _impl_.direction_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::snakes::Direction GameMessage_SteerMsg::_internal_direction() const {
  return static_cast< ::snakes::Direction >(_impl_.direction_);
}
inline ::snakes::Direction GameMessage_SteerMsg::direction() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.SteerMsg.direction)
  return _internal_direction();
}
inline void GameMessage_SteerMsg::_internal_set_direction(::snakes::Direction value) {
  assert(::snakes::Direction_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.direction_ = value;
}
inline void GameMessage_SteerMsg::set_direction(::snakes::Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.SteerMsg.direction)
}

// -------------------------------------------------------------------

// GameMessage_AckMsg

// -------------------------------------------------------------------

// GameMessage_StateMsg

// required .snakes.GameState state = 1;
inline bool GameMessage_StateMsg::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline bool GameMessage_StateMsg::has_state() const {
  return _internal_has_state();
}
inline void GameMessage_StateMsg::clear_state() {
  if (_impl_.state_ != nullptr) _impl_.state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::snakes::GameState& GameMessage_StateMsg::_internal_state() const {
  const ::snakes::GameState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::snakes::GameState&>(
      ::snakes::_GameState_default_instance_);
}
inline const ::snakes::GameState& GameMessage_StateMsg::state() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.StateMsg.state)
  return _internal_state();
}
inline void GameMessage_StateMsg::unsafe_arena_set_allocated_state(
    ::snakes::GameState* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.StateMsg.state)
}
inline ::snakes::GameState* GameMessage_StateMsg::release_state() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::snakes::GameState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::snakes::GameState* GameMessage_StateMsg::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.StateMsg.state)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::snakes::GameState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::snakes::GameState* GameMessage_StateMsg::_internal_mutable_state() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::snakes::GameState>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::snakes::GameState* GameMessage_StateMsg::mutable_state() {
  ::snakes::GameState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.StateMsg.state)
  return _msg;
}
inline void GameMessage_StateMsg::set_allocated_state(::snakes::GameState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.StateMsg.state)
}

// -------------------------------------------------------------------

// GameMessage_AnnouncementMsg

// repeated .snakes.GameAnnouncement games = 1;
inline int GameMessage_AnnouncementMsg::_internal_games_size() const {
  return _impl_.games_.size();
}
inline int GameMessage_AnnouncementMsg::games_size() const {
  return _internal_games_size();
}
inline void GameMessage_AnnouncementMsg::clear_games() {
  _impl_.games_.Clear();
}
inline ::snakes::GameAnnouncement* GameMessage_AnnouncementMsg::mutable_games(int index) {
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.AnnouncementMsg.games)
  return _impl_.games_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameAnnouncement >*
GameMessage_AnnouncementMsg::mutable_games() {
  // @@protoc_insertion_point(field_mutable_list:snakes.GameMessage.AnnouncementMsg.games)
  return &_impl_.games_;
}
inline const ::snakes::GameAnnouncement& GameMessage_AnnouncementMsg::_internal_games(int index) const {
  return _impl_.games_.Get(index);
}
inline const ::snakes::GameAnnouncement& GameMessage_AnnouncementMsg::games(int index) const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.AnnouncementMsg.games)
  return _internal_games(index);
}
inline ::snakes::GameAnnouncement* GameMessage_AnnouncementMsg::_internal_add_games() {
  return _impl_.games_.Add();
}
inline ::snakes::GameAnnouncement* GameMessage_AnnouncementMsg::add_games() {
  ::snakes::GameAnnouncement* _add = _internal_add_games();
  // @@protoc_insertion_point(field_add:snakes.GameMessage.AnnouncementMsg.games)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameAnnouncement >&
GameMessage_AnnouncementMsg::games() const {
  // @@protoc_insertion_point(field_list:snakes.GameMessage.AnnouncementMsg.games)
  return _impl_.games_;
}

// -------------------------------------------------------------------

// GameMessage_DiscoverMsg

// -------------------------------------------------------------------

// GameMessage_JoinMsg

// optional .snakes.PlayerType player_type = 1 [default = HUMAN];
inline bool GameMessage_JoinMsg::_internal_has_player_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GameMessage_JoinMsg::has_player_type() const {
  return _internal_has_player_type();
}
inline void GameMessage_JoinMsg::clear_player_type() {
  _impl_.player_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::snakes::PlayerType GameMessage_JoinMsg::_internal_player_type() const {
  return static_cast< ::snakes::PlayerType >(_impl_.player_type_);
}
inline ::snakes::PlayerType GameMessage_JoinMsg::player_type() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.JoinMsg.player_type)
  return _internal_player_type();
}
inline void GameMessage_JoinMsg::_internal_set_player_type(::snakes::PlayerType value) {
  assert(::snakes::PlayerType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.player_type_ = value;
}
inline void GameMessage_JoinMsg::set_player_type(::snakes::PlayerType value) {
  _internal_set_player_type(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.JoinMsg.player_type)
}

// required string player_name = 3;
inline bool GameMessage_JoinMsg::_internal_has_player_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameMessage_JoinMsg::has_player_name() const {
  return _internal_has_player_name();
}
inline void GameMessage_JoinMsg::clear_player_name() {
  _impl_.player_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GameMessage_JoinMsg::player_name() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.JoinMsg.player_name)
  return _internal_player_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameMessage_JoinMsg::set_player_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.player_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:snakes.GameMessage.JoinMsg.player_name)
}
inline std::string* GameMessage_JoinMsg::mutable_player_name() {
  std::string* _s = _internal_mutable_player_name();
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.JoinMsg.player_name)
  return _s;
}
inline const std::string& GameMessage_JoinMsg::_internal_player_name() const {
  return _impl_.player_name_.Get();
}
inline void GameMessage_JoinMsg::_internal_set_player_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.player_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GameMessage_JoinMsg::_internal_mutable_player_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.player_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GameMessage_JoinMsg::release_player_name() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.JoinMsg.player_name)
  if (!_internal_has_player_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.player_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.player_name_.IsDefault()) {
    _impl_.player_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GameMessage_JoinMsg::set_allocated_player_name(std::string* player_name) {
  if (player_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.player_name_.SetAllocated(player_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.player_name_.IsDefault()) {
    _impl_.player_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.JoinMsg.player_name)
}

// required string game_name = 4;
inline bool GameMessage_JoinMsg::_internal_has_game_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameMessage_JoinMsg::has_game_name() const {
  return _internal_has_game_name();
}
inline void GameMessage_JoinMsg::clear_game_name() {
  _impl_.game_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GameMessage_JoinMsg::game_name() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.JoinMsg.game_name)
  return _internal_game_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameMessage_JoinMsg::set_game_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.game_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:snakes.GameMessage.JoinMsg.game_name)
}
inline std::string* GameMessage_JoinMsg::mutable_game_name() {
  std::string* _s = _internal_mutable_game_name();
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.JoinMsg.game_name)
  return _s;
}
inline const std::string& GameMessage_JoinMsg::_internal_game_name() const {
  return _impl_.game_name_.Get();
}
inline void GameMessage_JoinMsg::_internal_set_game_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.game_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GameMessage_JoinMsg::_internal_mutable_game_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.game_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GameMessage_JoinMsg::release_game_name() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.JoinMsg.game_name)
  if (!_internal_has_game_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.game_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_name_.IsDefault()) {
    _impl_.game_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GameMessage_JoinMsg::set_allocated_game_name(std::string* game_name) {
  if (game_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.game_name_.SetAllocated(game_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_name_.IsDefault()) {
    _impl_.game_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.JoinMsg.game_name)
}

// required .snakes.NodeRole requested_role = 5;
inline bool GameMessage_JoinMsg::_internal_has_requested_role() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GameMessage_JoinMsg::has_requested_role() const {
  return _internal_has_requested_role();
}
inline void GameMessage_JoinMsg::clear_requested_role() {
  _impl_.requested_role_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::snakes::NodeRole GameMessage_JoinMsg::_internal_requested_role() const {
  return static_cast< ::snakes::NodeRole >(_impl_.requested_role_);
}
inline ::snakes::NodeRole GameMessage_JoinMsg::requested_role() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.JoinMsg.requested_role)
  return _internal_requested_role();
}
inline void GameMessage_JoinMsg::_internal_set_requested_role(::snakes::NodeRole value) {
  assert(::snakes::NodeRole_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.requested_role_ = value;
}
inline void GameMessage_JoinMsg::set_requested_role(::snakes::NodeRole value) {
  _internal_set_requested_role(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.JoinMsg.requested_role)
}

// -------------------------------------------------------------------

// GameMessage_ErrorMsg

// required string error_message = 1;
inline bool GameMessage_ErrorMsg::_internal_has_error_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameMessage_ErrorMsg::has_error_message() const {
  return _internal_has_error_message();
}
inline void GameMessage_ErrorMsg::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GameMessage_ErrorMsg::error_message() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.ErrorMsg.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameMessage_ErrorMsg::set_error_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:snakes.GameMessage.ErrorMsg.error_message)
}
inline std::string* GameMessage_ErrorMsg::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.ErrorMsg.error_message)
  return _s;
}
inline const std::string& GameMessage_ErrorMsg::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void GameMessage_ErrorMsg::_internal_set_error_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* GameMessage_ErrorMsg::_internal_mutable_error_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* GameMessage_ErrorMsg::release_error_message() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.ErrorMsg.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GameMessage_ErrorMsg::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.ErrorMsg.error_message)
}

// -------------------------------------------------------------------

// GameMessage_RoleChangeMsg

// optional .snakes.NodeRole sender_role = 1;
inline bool GameMessage_RoleChangeMsg::_internal_has_sender_role() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameMessage_RoleChangeMsg::has_sender_role() const {
  return _internal_has_sender_role();
}
inline void GameMessage_RoleChangeMsg::clear_sender_role() {
  _impl_.sender_role_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::snakes::NodeRole GameMessage_RoleChangeMsg::_internal_sender_role() const {
  return static_cast< ::snakes::NodeRole >(_impl_.sender_role_);
}
inline ::snakes::NodeRole GameMessage_RoleChangeMsg::sender_role() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.RoleChangeMsg.sender_role)
  return _internal_sender_role();
}
inline void GameMessage_RoleChangeMsg::_internal_set_sender_role(::snakes::NodeRole value) {
  assert(::snakes::NodeRole_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sender_role_ = value;
}
inline void GameMessage_RoleChangeMsg::set_sender_role(::snakes::NodeRole value) {
  _internal_set_sender_role(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.RoleChangeMsg.sender_role)
}

// optional .snakes.NodeRole receiver_role = 2;
inline bool GameMessage_RoleChangeMsg::_internal_has_receiver_role() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameMessage_RoleChangeMsg::has_receiver_role() const {
  return _internal_has_receiver_role();
}
inline void GameMessage_RoleChangeMsg::clear_receiver_role() {
  _impl_.receiver_role_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::snakes::NodeRole GameMessage_RoleChangeMsg::_internal_receiver_role() const {
  return static_cast< ::snakes::NodeRole >(_impl_.receiver_role_);
}
inline ::snakes::NodeRole GameMessage_RoleChangeMsg::receiver_role() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.RoleChangeMsg.receiver_role)
  return _internal_receiver_role();
}
inline void GameMessage_RoleChangeMsg::_internal_set_receiver_role(::snakes::NodeRole value) {
  assert(::snakes::NodeRole_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.receiver_role_ = value;
}
inline void GameMessage_RoleChangeMsg::set_receiver_role(::snakes::NodeRole value) {
  _internal_set_receiver_role(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.RoleChangeMsg.receiver_role)
}

// -------------------------------------------------------------------

// GameMessage

// required int64 msg_seq = 1;
inline bool GameMessage::_internal_has_msg_seq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameMessage::has_msg_seq() const {
  return _internal_has_msg_seq();
}
inline void GameMessage::clear_msg_seq() {
  _impl_.msg_seq_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t GameMessage::_internal_msg_seq() const {
  return _impl_.msg_seq_;
}
inline int64_t GameMessage::msg_seq() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.msg_seq)
  return _internal_msg_seq();
}
inline void GameMessage::_internal_set_msg_seq(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_seq_ = value;
}
inline void GameMessage::set_msg_seq(int64_t value) {
  _internal_set_msg_seq(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.msg_seq)
}

// optional int32 sender_id = 10;
inline bool GameMessage::_internal_has_sender_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameMessage::has_sender_id() const {
  return _internal_has_sender_id();
}
inline void GameMessage::clear_sender_id() {
  _impl_.sender_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t GameMessage::_internal_sender_id() const {
  return _impl_.sender_id_;
}
inline int32_t GameMessage::sender_id() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.sender_id)
  return _internal_sender_id();
}
inline void GameMessage::_internal_set_sender_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sender_id_ = value;
}
inline void GameMessage::set_sender_id(int32_t value) {
  _internal_set_sender_id(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.sender_id)
}

// optional int32 receiver_id = 11;
inline bool GameMessage::_internal_has_receiver_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GameMessage::has_receiver_id() const {
  return _internal_has_receiver_id();
}
inline void GameMessage::clear_receiver_id() {
  _impl_.receiver_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t GameMessage::_internal_receiver_id() const {
  return _impl_.receiver_id_;
}
inline int32_t GameMessage::receiver_id() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.receiver_id)
  return _internal_receiver_id();
}
inline void GameMessage::_internal_set_receiver_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.receiver_id_ = value;
}
inline void GameMessage::set_receiver_id(int32_t value) {
  _internal_set_receiver_id(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.receiver_id)
}

// .snakes.GameMessage.PingMsg ping = 2;
inline bool GameMessage::_internal_has_ping() const {
  return Type_case() == kPing;
}
inline bool GameMessage::has_ping() const {
  return _internal_has_ping();
}
inline void GameMessage::set_has_ping() {
  _impl_._oneof_case_[0] = kPing;
}
inline void GameMessage::clear_ping() {
  if (_internal_has_ping()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Type_.ping_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_PingMsg* GameMessage::release_ping() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.ping)
  if (_internal_has_ping()) {
    clear_has_Type();
    ::snakes::GameMessage_PingMsg* temp = _impl_.Type_.ping_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Type_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_PingMsg& GameMessage::_internal_ping() const {
  return _internal_has_ping()
      ? *_impl_.Type_.ping_
      : reinterpret_cast< ::snakes::GameMessage_PingMsg&>(::snakes::_GameMessage_PingMsg_default_instance_);
}
inline const ::snakes::GameMessage_PingMsg& GameMessage::ping() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.ping)
  return _internal_ping();
}
inline ::snakes::GameMessage_PingMsg* GameMessage::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.ping)
  if (_internal_has_ping()) {
    clear_has_Type();
    ::snakes::GameMessage_PingMsg* temp = _impl_.Type_.ping_;
    _impl_.Type_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_ping(::snakes::GameMessage_PingMsg* ping) {
  clear_Type();
  if (ping) {
    set_has_ping();
    _impl_.Type_.ping_ = ping;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.ping)
}
inline ::snakes::GameMessage_PingMsg* GameMessage::_internal_mutable_ping() {
  if (!_internal_has_ping()) {
    clear_Type();
    set_has_ping();
    _impl_.Type_.ping_ = CreateMaybeMessage< ::snakes::GameMessage_PingMsg >(GetArenaForAllocation());
  }
  return _impl_.Type_.ping_;
}
inline ::snakes::GameMessage_PingMsg* GameMessage::mutable_ping() {
  ::snakes::GameMessage_PingMsg* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.ping)
  return _msg;
}

// .snakes.GameMessage.SteerMsg steer = 3;
inline bool GameMessage::_internal_has_steer() const {
  return Type_case() == kSteer;
}
inline bool GameMessage::has_steer() const {
  return _internal_has_steer();
}
inline void GameMessage::set_has_steer() {
  _impl_._oneof_case_[0] = kSteer;
}
inline void GameMessage::clear_steer() {
  if (_internal_has_steer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Type_.steer_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_SteerMsg* GameMessage::release_steer() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.steer)
  if (_internal_has_steer()) {
    clear_has_Type();
    ::snakes::GameMessage_SteerMsg* temp = _impl_.Type_.steer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Type_.steer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_SteerMsg& GameMessage::_internal_steer() const {
  return _internal_has_steer()
      ? *_impl_.Type_.steer_
      : reinterpret_cast< ::snakes::GameMessage_SteerMsg&>(::snakes::_GameMessage_SteerMsg_default_instance_);
}
inline const ::snakes::GameMessage_SteerMsg& GameMessage::steer() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.steer)
  return _internal_steer();
}
inline ::snakes::GameMessage_SteerMsg* GameMessage::unsafe_arena_release_steer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.steer)
  if (_internal_has_steer()) {
    clear_has_Type();
    ::snakes::GameMessage_SteerMsg* temp = _impl_.Type_.steer_;
    _impl_.Type_.steer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_steer(::snakes::GameMessage_SteerMsg* steer) {
  clear_Type();
  if (steer) {
    set_has_steer();
    _impl_.Type_.steer_ = steer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.steer)
}
inline ::snakes::GameMessage_SteerMsg* GameMessage::_internal_mutable_steer() {
  if (!_internal_has_steer()) {
    clear_Type();
    set_has_steer();
    _impl_.Type_.steer_ = CreateMaybeMessage< ::snakes::GameMessage_SteerMsg >(GetArenaForAllocation());
  }
  return _impl_.Type_.steer_;
}
inline ::snakes::GameMessage_SteerMsg* GameMessage::mutable_steer() {
  ::snakes::GameMessage_SteerMsg* _msg = _internal_mutable_steer();
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.steer)
  return _msg;
}

// .snakes.GameMessage.AckMsg ack = 4;
inline bool GameMessage::_internal_has_ack() const {
  return Type_case() == kAck;
}
inline bool GameMessage::has_ack() const {
  return _internal_has_ack();
}
inline void GameMessage::set_has_ack() {
  _impl_._oneof_case_[0] = kAck;
}
inline void GameMessage::clear_ack() {
  if (_internal_has_ack()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Type_.ack_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_AckMsg* GameMessage::release_ack() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.ack)
  if (_internal_has_ack()) {
    clear_has_Type();
    ::snakes::GameMessage_AckMsg* temp = _impl_.Type_.ack_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Type_.ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_AckMsg& GameMessage::_internal_ack() const {
  return _internal_has_ack()
      ? *_impl_.Type_.ack_
      : reinterpret_cast< ::snakes::GameMessage_AckMsg&>(::snakes::_GameMessage_AckMsg_default_instance_);
}
inline const ::snakes::GameMessage_AckMsg& GameMessage::ack() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.ack)
  return _internal_ack();
}
inline ::snakes::GameMessage_AckMsg* GameMessage::unsafe_arena_release_ack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.ack)
  if (_internal_has_ack()) {
    clear_has_Type();
    ::snakes::GameMessage_AckMsg* temp = _impl_.Type_.ack_;
    _impl_.Type_.ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_ack(::snakes::GameMessage_AckMsg* ack) {
  clear_Type();
  if (ack) {
    set_has_ack();
    _impl_.Type_.ack_ = ack;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.ack)
}
inline ::snakes::GameMessage_AckMsg* GameMessage::_internal_mutable_ack() {
  if (!_internal_has_ack()) {
    clear_Type();
    set_has_ack();
    _impl_.Type_.ack_ = CreateMaybeMessage< ::snakes::GameMessage_AckMsg >(GetArenaForAllocation());
  }
  return _impl_.Type_.ack_;
}
inline ::snakes::GameMessage_AckMsg* GameMessage::mutable_ack() {
  ::snakes::GameMessage_AckMsg* _msg = _internal_mutable_ack();
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.ack)
  return _msg;
}

// .snakes.GameMessage.StateMsg state = 5;
inline bool GameMessage::_internal_has_state() const {
  return Type_case() == kState;
}
inline bool GameMessage::has_state() const {
  return _internal_has_state();
}
inline void GameMessage::set_has_state() {
  _impl_._oneof_case_[0] = kState;
}
inline void GameMessage::clear_state() {
  if (_internal_has_state()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Type_.state_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_StateMsg* GameMessage::release_state() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.state)
  if (_internal_has_state()) {
    clear_has_Type();
    ::snakes::GameMessage_StateMsg* temp = _impl_.Type_.state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Type_.state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_StateMsg& GameMessage::_internal_state() const {
  return _internal_has_state()
      ? *_impl_.Type_.state_
      : reinterpret_cast< ::snakes::GameMessage_StateMsg&>(::snakes::_GameMessage_StateMsg_default_instance_);
}
inline const ::snakes::GameMessage_StateMsg& GameMessage::state() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.state)
  return _internal_state();
}
inline ::snakes::GameMessage_StateMsg* GameMessage::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.state)
  if (_internal_has_state()) {
    clear_has_Type();
    ::snakes::GameMessage_StateMsg* temp = _impl_.Type_.state_;
    _impl_.Type_.state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_state(::snakes::GameMessage_StateMsg* state) {
  clear_Type();
  if (state) {
    set_has_state();
    _impl_.Type_.state_ = state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.state)
}
inline ::snakes::GameMessage_StateMsg* GameMessage::_internal_mutable_state() {
  if (!_internal_has_state()) {
    clear_Type();
    set_has_state();
    _impl_.Type_.state_ = CreateMaybeMessage< ::snakes::GameMessage_StateMsg >(GetArenaForAllocation());
  }
  return _impl_.Type_.state_;
}
inline ::snakes::GameMessage_StateMsg* GameMessage::mutable_state() {
  ::snakes::GameMessage_StateMsg* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.state)
  return _msg;
}

// .snakes.GameMessage.AnnouncementMsg announcement = 6;
inline bool GameMessage::_internal_has_announcement() const {
  return Type_case() == kAnnouncement;
}
inline bool GameMessage::has_announcement() const {
  return _internal_has_announcement();
}
inline void GameMessage::set_has_announcement() {
  _impl_._oneof_case_[0] = kAnnouncement;
}
inline void GameMessage::clear_announcement() {
  if (_internal_has_announcement()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Type_.announcement_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_AnnouncementMsg* GameMessage::release_announcement() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.announcement)
  if (_internal_has_announcement()) {
    clear_has_Type();
    ::snakes::GameMessage_AnnouncementMsg* temp = _impl_.Type_.announcement_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Type_.announcement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_AnnouncementMsg& GameMessage::_internal_announcement() const {
  return _internal_has_announcement()
      ? *_impl_.Type_.announcement_
      : reinterpret_cast< ::snakes::GameMessage_AnnouncementMsg&>(::snakes::_GameMessage_AnnouncementMsg_default_instance_);
}
inline const ::snakes::GameMessage_AnnouncementMsg& GameMessage::announcement() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.announcement)
  return _internal_announcement();
}
inline ::snakes::GameMessage_AnnouncementMsg* GameMessage::unsafe_arena_release_announcement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.announcement)
  if (_internal_has_announcement()) {
    clear_has_Type();
    ::snakes::GameMessage_AnnouncementMsg* temp = _impl_.Type_.announcement_;
    _impl_.Type_.announcement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_announcement(::snakes::GameMessage_AnnouncementMsg* announcement) {
  clear_Type();
  if (announcement) {
    set_has_announcement();
    _impl_.Type_.announcement_ = announcement;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.announcement)
}
inline ::snakes::GameMessage_AnnouncementMsg* GameMessage::_internal_mutable_announcement() {
  if (!_internal_has_announcement()) {
    clear_Type();
    set_has_announcement();
    _impl_.Type_.announcement_ = CreateMaybeMessage< ::snakes::GameMessage_AnnouncementMsg >(GetArenaForAllocation());
  }
  return _impl_.Type_.announcement_;
}
inline ::snakes::GameMessage_AnnouncementMsg* GameMessage::mutable_announcement() {
  ::snakes::GameMessage_AnnouncementMsg* _msg = _internal_mutable_announcement();
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.announcement)
  return _msg;
}

// .snakes.GameMessage.JoinMsg join = 7;
inline bool GameMessage::_internal_has_join() const {
  return Type_case() == kJoin;
}
inline bool GameMessage::has_join() const {
  return _internal_has_join();
}
inline void GameMessage::set_has_join() {
  _impl_._oneof_case_[0] = kJoin;
}
inline void GameMessage::clear_join() {
  if (_internal_has_join()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Type_.join_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_JoinMsg* GameMessage::release_join() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.join)
  if (_internal_has_join()) {
    clear_has_Type();
    ::snakes::GameMessage_JoinMsg* temp = _impl_.Type_.join_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Type_.join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_JoinMsg& GameMessage::_internal_join() const {
  return _internal_has_join()
      ? *_impl_.Type_.join_
      : reinterpret_cast< ::snakes::GameMessage_JoinMsg&>(::snakes::_GameMessage_JoinMsg_default_instance_);
}
inline const ::snakes::GameMessage_JoinMsg& GameMessage::join() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.join)
  return _internal_join();
}
inline ::snakes::GameMessage_JoinMsg* GameMessage::unsafe_arena_release_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.join)
  if (_internal_has_join()) {
    clear_has_Type();
    ::snakes::GameMessage_JoinMsg* temp = _impl_.Type_.join_;
    _impl_.Type_.join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_join(::snakes::GameMessage_JoinMsg* join) {
  clear_Type();
  if (join) {
    set_has_join();
    _impl_.Type_.join_ = join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.join)
}
inline ::snakes::GameMessage_JoinMsg* GameMessage::_internal_mutable_join() {
  if (!_internal_has_join()) {
    clear_Type();
    set_has_join();
    _impl_.Type_.join_ = CreateMaybeMessage< ::snakes::GameMessage_JoinMsg >(GetArenaForAllocation());
  }
  return _impl_.Type_.join_;
}
inline ::snakes::GameMessage_JoinMsg* GameMessage::mutable_join() {
  ::snakes::GameMessage_JoinMsg* _msg = _internal_mutable_join();
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.join)
  return _msg;
}

// .snakes.GameMessage.ErrorMsg error = 8;
inline bool GameMessage::_internal_has_error() const {
  return Type_case() == kError;
}
inline bool GameMessage::has_error() const {
  return _internal_has_error();
}
inline void GameMessage::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void GameMessage::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Type_.error_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_ErrorMsg* GameMessage::release_error() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.error)
  if (_internal_has_error()) {
    clear_has_Type();
    ::snakes::GameMessage_ErrorMsg* temp = _impl_.Type_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Type_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_ErrorMsg& GameMessage::_internal_error() const {
  return _internal_has_error()
      ? *_impl_.Type_.error_
      : reinterpret_cast< ::snakes::GameMessage_ErrorMsg&>(::snakes::_GameMessage_ErrorMsg_default_instance_);
}
inline const ::snakes::GameMessage_ErrorMsg& GameMessage::error() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.error)
  return _internal_error();
}
inline ::snakes::GameMessage_ErrorMsg* GameMessage::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.error)
  if (_internal_has_error()) {
    clear_has_Type();
    ::snakes::GameMessage_ErrorMsg* temp = _impl_.Type_.error_;
    _impl_.Type_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_error(::snakes::GameMessage_ErrorMsg* error) {
  clear_Type();
  if (error) {
    set_has_error();
    _impl_.Type_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.error)
}
inline ::snakes::GameMessage_ErrorMsg* GameMessage::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Type();
    set_has_error();
    _impl_.Type_.error_ = CreateMaybeMessage< ::snakes::GameMessage_ErrorMsg >(GetArenaForAllocation());
  }
  return _impl_.Type_.error_;
}
inline ::snakes::GameMessage_ErrorMsg* GameMessage::mutable_error() {
  ::snakes::GameMessage_ErrorMsg* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.error)
  return _msg;
}

// .snakes.GameMessage.RoleChangeMsg role_change = 9;
inline bool GameMessage::_internal_has_role_change() const {
  return Type_case() == kRoleChange;
}
inline bool GameMessage::has_role_change() const {
  return _internal_has_role_change();
}
inline void GameMessage::set_has_role_change() {
  _impl_._oneof_case_[0] = kRoleChange;
}
inline void GameMessage::clear_role_change() {
  if (_internal_has_role_change()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Type_.role_change_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_RoleChangeMsg* GameMessage::release_role_change() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.role_change)
  if (_internal_has_role_change()) {
    clear_has_Type();
    ::snakes::GameMessage_RoleChangeMsg* temp = _impl_.Type_.role_change_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Type_.role_change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_RoleChangeMsg& GameMessage::_internal_role_change() const {
  return _internal_has_role_change()
      ? *_impl_.Type_.role_change_
      : reinterpret_cast< ::snakes::GameMessage_RoleChangeMsg&>(::snakes::_GameMessage_RoleChangeMsg_default_instance_);
}
inline const ::snakes::GameMessage_RoleChangeMsg& GameMessage::role_change() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.role_change)
  return _internal_role_change();
}
inline ::snakes::GameMessage_RoleChangeMsg* GameMessage::unsafe_arena_release_role_change() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.role_change)
  if (_internal_has_role_change()) {
    clear_has_Type();
    ::snakes::GameMessage_RoleChangeMsg* temp = _impl_.Type_.role_change_;
    _impl_.Type_.role_change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_role_change(::snakes::GameMessage_RoleChangeMsg* role_change) {
  clear_Type();
  if (role_change) {
    set_has_role_change();
    _impl_.Type_.role_change_ = role_change;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.role_change)
}
inline ::snakes::GameMessage_RoleChangeMsg* GameMessage::_internal_mutable_role_change() {
  if (!_internal_has_role_change()) {
    clear_Type();
    set_has_role_change();
    _impl_.Type_.role_change_ = CreateMaybeMessage< ::snakes::GameMessage_RoleChangeMsg >(GetArenaForAllocation());
  }
  return _impl_.Type_.role_change_;
}
inline ::snakes::GameMessage_RoleChangeMsg* GameMessage::mutable_role_change() {
  ::snakes::GameMessage_RoleChangeMsg* _msg = _internal_mutable_role_change();
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.role_change)
  return _msg;
}

// .snakes.GameMessage.DiscoverMsg discover = 12;
inline bool GameMessage::_internal_has_discover() const {
  return Type_case() == kDiscover;
}
inline bool GameMessage::has_discover() const {
  return _internal_has_discover();
}
inline void GameMessage::set_has_discover() {
  _impl_._oneof_case_[0] = kDiscover;
}
inline void GameMessage::clear_discover() {
  if (_internal_has_discover()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.Type_.discover_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_DiscoverMsg* GameMessage::release_discover() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.discover)
  if (_internal_has_discover()) {
    clear_has_Type();
    ::snakes::GameMessage_DiscoverMsg* temp = _impl_.Type_.discover_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Type_.discover_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_DiscoverMsg& GameMessage::_internal_discover() const {
  return _internal_has_discover()
      ? *_impl_.Type_.discover_
      : reinterpret_cast< ::snakes::GameMessage_DiscoverMsg&>(::snakes::_GameMessage_DiscoverMsg_default_instance_);
}
inline const ::snakes::GameMessage_DiscoverMsg& GameMessage::discover() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.discover)
  return _internal_discover();
}
inline ::snakes::GameMessage_DiscoverMsg* GameMessage::unsafe_arena_release_discover() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.discover)
  if (_internal_has_discover()) {
    clear_has_Type();
    ::snakes::GameMessage_DiscoverMsg* temp = _impl_.Type_.discover_;
    _impl_.Type_.discover_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_discover(::snakes::GameMessage_DiscoverMsg* discover) {
  clear_Type();
  if (discover) {
    set_has_discover();
    _impl_.Type_.discover_ = discover;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.discover)
}
inline ::snakes::GameMessage_DiscoverMsg* GameMessage::_internal_mutable_discover() {
  if (!_internal_has_discover()) {
    clear_Type();
    set_has_discover();
    _impl_.Type_.discover_ = CreateMaybeMessage< ::snakes::GameMessage_DiscoverMsg >(GetArenaForAllocation());
  }
  return _impl_.Type_.discover_;
}
inline ::snakes::GameMessage_DiscoverMsg* GameMessage::mutable_discover() {
  ::snakes::GameMessage_DiscoverMsg* _msg = _internal_mutable_discover();
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.discover)
  return _msg;
}

inline bool GameMessage::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void GameMessage::clear_has_Type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline GameMessage::TypeCase GameMessage::Type_case() const {
  return GameMessage::TypeCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace snakes

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::snakes::GameState_Snake_SnakeState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snakes::GameState_Snake_SnakeState>() {
  return ::snakes::GameState_Snake_SnakeState_descriptor();
}
template <> struct is_proto_enum< ::snakes::NodeRole> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snakes::NodeRole>() {
  return ::snakes::NodeRole_descriptor();
}
template <> struct is_proto_enum< ::snakes::PlayerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snakes::PlayerType>() {
  return ::snakes::PlayerType_descriptor();
}
template <> struct is_proto_enum< ::snakes::Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snakes::Direction>() {
  return ::snakes::Direction_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_snakes_2eproto
