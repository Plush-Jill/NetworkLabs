// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: snakes.proto

#include "snakes.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace snakes {
PROTOBUF_CONSTEXPR GamePlayer::GamePlayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ip_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.port_)*/0
  , /*decltype(_impl_.role_)*/0
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.score_)*/0} {}
struct GamePlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GamePlayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GamePlayerDefaultTypeInternal() {}
  union {
    GamePlayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GamePlayerDefaultTypeInternal _GamePlayer_default_instance_;
PROTOBUF_CONSTEXPR GameConfig::GameConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.width_)*/40
  , /*decltype(_impl_.height_)*/30
  , /*decltype(_impl_.food_static_)*/1
  , /*decltype(_impl_.state_delay_ms_)*/1000} {}
struct GameConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameConfigDefaultTypeInternal() {}
  union {
    GameConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameConfigDefaultTypeInternal _GameConfig_default_instance_;
PROTOBUF_CONSTEXPR GamePlayers::GamePlayers(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.players_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GamePlayersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GamePlayersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GamePlayersDefaultTypeInternal() {}
  union {
    GamePlayers _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GamePlayersDefaultTypeInternal _GamePlayers_default_instance_;
PROTOBUF_CONSTEXPR GameState_Coord::GameState_Coord(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct GameState_CoordDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameState_CoordDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameState_CoordDefaultTypeInternal() {}
  union {
    GameState_Coord _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameState_CoordDefaultTypeInternal _GameState_Coord_default_instance_;
PROTOBUF_CONSTEXPR GameState_Snake::GameState_Snake(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.points_)*/{}
  , /*decltype(_impl_.player_id_)*/0
  , /*decltype(_impl_.state_)*/0
  , /*decltype(_impl_.head_direction_)*/1} {}
struct GameState_SnakeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameState_SnakeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameState_SnakeDefaultTypeInternal() {}
  union {
    GameState_Snake _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameState_SnakeDefaultTypeInternal _GameState_Snake_default_instance_;
PROTOBUF_CONSTEXPR GameState::GameState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.snakes_)*/{}
  , /*decltype(_impl_.foods_)*/{}
  , /*decltype(_impl_.players_)*/nullptr
  , /*decltype(_impl_.state_order_)*/0} {}
struct GameStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameStateDefaultTypeInternal() {}
  union {
    GameState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameStateDefaultTypeInternal _GameState_default_instance_;
PROTOBUF_CONSTEXPR GameAnnouncement::GameAnnouncement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.game_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.players_)*/nullptr
  , /*decltype(_impl_.config_)*/nullptr
  , /*decltype(_impl_.can_join_)*/true} {}
struct GameAnnouncementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameAnnouncementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameAnnouncementDefaultTypeInternal() {}
  union {
    GameAnnouncement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameAnnouncementDefaultTypeInternal _GameAnnouncement_default_instance_;
PROTOBUF_CONSTEXPR GameMessage_PingMsg::GameMessage_PingMsg(
    ::_pbi::ConstantInitialized) {}
struct GameMessage_PingMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameMessage_PingMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameMessage_PingMsgDefaultTypeInternal() {}
  union {
    GameMessage_PingMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameMessage_PingMsgDefaultTypeInternal _GameMessage_PingMsg_default_instance_;
PROTOBUF_CONSTEXPR GameMessage_SteerMsg::GameMessage_SteerMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.direction_)*/1} {}
struct GameMessage_SteerMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameMessage_SteerMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameMessage_SteerMsgDefaultTypeInternal() {}
  union {
    GameMessage_SteerMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameMessage_SteerMsgDefaultTypeInternal _GameMessage_SteerMsg_default_instance_;
PROTOBUF_CONSTEXPR GameMessage_AckMsg::GameMessage_AckMsg(
    ::_pbi::ConstantInitialized) {}
struct GameMessage_AckMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameMessage_AckMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameMessage_AckMsgDefaultTypeInternal() {}
  union {
    GameMessage_AckMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameMessage_AckMsgDefaultTypeInternal _GameMessage_AckMsg_default_instance_;
PROTOBUF_CONSTEXPR GameMessage_StateMsg::GameMessage_StateMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.state_)*/nullptr} {}
struct GameMessage_StateMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameMessage_StateMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameMessage_StateMsgDefaultTypeInternal() {}
  union {
    GameMessage_StateMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameMessage_StateMsgDefaultTypeInternal _GameMessage_StateMsg_default_instance_;
PROTOBUF_CONSTEXPR GameMessage_AnnouncementMsg::GameMessage_AnnouncementMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.games_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GameMessage_AnnouncementMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameMessage_AnnouncementMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameMessage_AnnouncementMsgDefaultTypeInternal() {}
  union {
    GameMessage_AnnouncementMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameMessage_AnnouncementMsgDefaultTypeInternal _GameMessage_AnnouncementMsg_default_instance_;
PROTOBUF_CONSTEXPR GameMessage_DiscoverMsg::GameMessage_DiscoverMsg(
    ::_pbi::ConstantInitialized) {}
struct GameMessage_DiscoverMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameMessage_DiscoverMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameMessage_DiscoverMsgDefaultTypeInternal() {}
  union {
    GameMessage_DiscoverMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameMessage_DiscoverMsgDefaultTypeInternal _GameMessage_DiscoverMsg_default_instance_;
PROTOBUF_CONSTEXPR GameMessage_JoinMsg::GameMessage_JoinMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.player_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.game_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.player_type_)*/0
  , /*decltype(_impl_.requested_role_)*/0} {}
struct GameMessage_JoinMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameMessage_JoinMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameMessage_JoinMsgDefaultTypeInternal() {}
  union {
    GameMessage_JoinMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameMessage_JoinMsgDefaultTypeInternal _GameMessage_JoinMsg_default_instance_;
PROTOBUF_CONSTEXPR GameMessage_ErrorMsg::GameMessage_ErrorMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.error_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct GameMessage_ErrorMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameMessage_ErrorMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameMessage_ErrorMsgDefaultTypeInternal() {}
  union {
    GameMessage_ErrorMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameMessage_ErrorMsgDefaultTypeInternal _GameMessage_ErrorMsg_default_instance_;
PROTOBUF_CONSTEXPR GameMessage_RoleChangeMsg::GameMessage_RoleChangeMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sender_role_)*/0
  , /*decltype(_impl_.receiver_role_)*/0} {}
struct GameMessage_RoleChangeMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameMessage_RoleChangeMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameMessage_RoleChangeMsgDefaultTypeInternal() {}
  union {
    GameMessage_RoleChangeMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameMessage_RoleChangeMsgDefaultTypeInternal _GameMessage_RoleChangeMsg_default_instance_;
PROTOBUF_CONSTEXPR GameMessage::GameMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.msg_seq_)*/int64_t{0}
  , /*decltype(_impl_.sender_id_)*/0
  , /*decltype(_impl_.receiver_id_)*/0
  , /*decltype(_impl_.Type_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct GameMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameMessageDefaultTypeInternal() {}
  union {
    GameMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameMessageDefaultTypeInternal _GameMessage_default_instance_;
}  // namespace snakes
static ::_pb::Metadata file_level_metadata_snakes_2eproto[17];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_snakes_2eproto[4];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_snakes_2eproto = nullptr;

const uint32_t TableStruct_snakes_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::snakes::GamePlayer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::snakes::GamePlayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GamePlayer, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::snakes::GamePlayer, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::snakes::GamePlayer, _impl_.ip_address_),
  PROTOBUF_FIELD_OFFSET(::snakes::GamePlayer, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::snakes::GamePlayer, _impl_.role_),
  PROTOBUF_FIELD_OFFSET(::snakes::GamePlayer, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::snakes::GamePlayer, _impl_.score_),
  0,
  2,
  1,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::snakes::GameConfig, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GameConfig, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameConfig, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameConfig, _impl_.food_static_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameConfig, _impl_.state_delay_ms_),
  0,
  1,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::snakes::GamePlayers, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GamePlayers, _impl_.players_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameState_Coord, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameState_Coord, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GameState_Coord, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameState_Coord, _impl_.y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::snakes::GameState_Snake, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameState_Snake, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GameState_Snake, _impl_.player_id_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameState_Snake, _impl_.points_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameState_Snake, _impl_.state_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameState_Snake, _impl_.head_direction_),
  0,
  ~0u,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::snakes::GameState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GameState, _impl_.state_order_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameState, _impl_.snakes_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameState, _impl_.foods_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameState, _impl_.players_),
  1,
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::snakes::GameAnnouncement, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameAnnouncement, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GameAnnouncement, _impl_.players_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameAnnouncement, _impl_.config_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameAnnouncement, _impl_.can_join_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameAnnouncement, _impl_.game_name_),
  1,
  2,
  3,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_PingMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_SteerMsg, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_SteerMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_SteerMsg, _impl_.direction_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_AckMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_StateMsg, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_StateMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_StateMsg, _impl_.state_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_AnnouncementMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_AnnouncementMsg, _impl_.games_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_DiscoverMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_JoinMsg, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_JoinMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_JoinMsg, _impl_.player_type_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_JoinMsg, _impl_.player_name_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_JoinMsg, _impl_.game_name_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_JoinMsg, _impl_.requested_role_),
  2,
  0,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_ErrorMsg, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_ErrorMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_ErrorMsg, _impl_.error_message_),
  0,
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_RoleChangeMsg, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_RoleChangeMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_RoleChangeMsg, _impl_.sender_role_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage_RoleChangeMsg, _impl_.receiver_role_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage, _impl_.msg_seq_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage, _impl_.sender_id_),
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage, _impl_.receiver_id_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::snakes::GameMessage, _impl_.Type_),
  0,
  1,
  2,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 13, -1, sizeof(::snakes::GamePlayer)},
  { 20, 30, -1, sizeof(::snakes::GameConfig)},
  { 34, -1, -1, sizeof(::snakes::GamePlayers)},
  { 41, 49, -1, sizeof(::snakes::GameState_Coord)},
  { 51, 61, -1, sizeof(::snakes::GameState_Snake)},
  { 65, 75, -1, sizeof(::snakes::GameState)},
  { 79, 89, -1, sizeof(::snakes::GameAnnouncement)},
  { 93, -1, -1, sizeof(::snakes::GameMessage_PingMsg)},
  { 99, 106, -1, sizeof(::snakes::GameMessage_SteerMsg)},
  { 107, -1, -1, sizeof(::snakes::GameMessage_AckMsg)},
  { 113, 120, -1, sizeof(::snakes::GameMessage_StateMsg)},
  { 121, -1, -1, sizeof(::snakes::GameMessage_AnnouncementMsg)},
  { 128, -1, -1, sizeof(::snakes::GameMessage_DiscoverMsg)},
  { 134, 144, -1, sizeof(::snakes::GameMessage_JoinMsg)},
  { 148, 155, -1, sizeof(::snakes::GameMessage_ErrorMsg)},
  { 156, 164, -1, sizeof(::snakes::GameMessage_RoleChangeMsg)},
  { 166, 185, -1, sizeof(::snakes::GameMessage)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::snakes::_GamePlayer_default_instance_._instance,
  &::snakes::_GameConfig_default_instance_._instance,
  &::snakes::_GamePlayers_default_instance_._instance,
  &::snakes::_GameState_Coord_default_instance_._instance,
  &::snakes::_GameState_Snake_default_instance_._instance,
  &::snakes::_GameState_default_instance_._instance,
  &::snakes::_GameAnnouncement_default_instance_._instance,
  &::snakes::_GameMessage_PingMsg_default_instance_._instance,
  &::snakes::_GameMessage_SteerMsg_default_instance_._instance,
  &::snakes::_GameMessage_AckMsg_default_instance_._instance,
  &::snakes::_GameMessage_StateMsg_default_instance_._instance,
  &::snakes::_GameMessage_AnnouncementMsg_default_instance_._instance,
  &::snakes::_GameMessage_DiscoverMsg_default_instance_._instance,
  &::snakes::_GameMessage_JoinMsg_default_instance_._instance,
  &::snakes::_GameMessage_ErrorMsg_default_instance_._instance,
  &::snakes::_GameMessage_RoleChangeMsg_default_instance_._instance,
  &::snakes::_GameMessage_default_instance_._instance,
};

const char descriptor_table_protodef_snakes_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\014snakes.proto\022\006snakes\"\240\001\n\nGamePlayer\022\014\n"
  "\004name\030\001 \002(\t\022\n\n\002id\030\002 \002(\005\022\022\n\nip_address\030\003 "
  "\001(\t\022\014\n\004port\030\004 \001(\005\022\036\n\004role\030\005 \002(\0162\020.snakes"
  ".NodeRole\022\'\n\004type\030\006 \001(\0162\022.snakes.PlayerT"
  "ype:\005HUMAN\022\r\n\005score\030\007 \002(\005\"i\n\nGameConfig\022"
  "\021\n\005width\030\001 \001(\005:\00240\022\022\n\006height\030\002 \001(\005:\00230\022\026"
  "\n\013food_static\030\003 \001(\005:\0011\022\034\n\016state_delay_ms"
  "\030\005 \001(\005:\0041000\"2\n\013GamePlayers\022#\n\007players\030\001"
  " \003(\0132\022.snakes.GamePlayer\"\214\003\n\tGameState\022\023"
  "\n\013state_order\030\001 \002(\005\022\'\n\006snakes\030\002 \003(\0132\027.sn"
  "akes.GameState.Snake\022&\n\005foods\030\003 \003(\0132\027.sn"
  "akes.GameState.Coord\022$\n\007players\030\004 \002(\0132\023."
  "snakes.GamePlayers\032#\n\005Coord\022\014\n\001x\030\001 \001(\021:\001"
  "0\022\014\n\001y\030\002 \001(\021:\0010\032\315\001\n\005Snake\022\021\n\tplayer_id\030\001"
  " \002(\005\022\'\n\006points\030\002 \003(\0132\027.snakes.GameState."
  "Coord\0228\n\005state\030\003 \002(\0162\".snakes.GameState."
  "Snake.SnakeState:\005ALIVE\022)\n\016head_directio"
  "n\030\004 \002(\0162\021.snakes.Direction\"#\n\nSnakeState"
  "\022\t\n\005ALIVE\020\000\022\n\n\006ZOMBIE\020\001\"\207\001\n\020GameAnnounce"
  "ment\022$\n\007players\030\001 \002(\0132\023.snakes.GamePlaye"
  "rs\022\"\n\006config\030\002 \002(\0132\022.snakes.GameConfig\022\026"
  "\n\010can_join\030\003 \001(\010:\004true\022\021\n\tgame_name\030\004 \002("
  "\t\"\336\007\n\013GameMessage\022\017\n\007msg_seq\030\001 \002(\003\022\021\n\tse"
  "nder_id\030\n \001(\005\022\023\n\013receiver_id\030\013 \001(\005\022+\n\004pi"
  "ng\030\002 \001(\0132\033.snakes.GameMessage.PingMsgH\000\022"
  "-\n\005steer\030\003 \001(\0132\034.snakes.GameMessage.Stee"
  "rMsgH\000\022)\n\003ack\030\004 \001(\0132\032.snakes.GameMessage"
  ".AckMsgH\000\022-\n\005state\030\005 \001(\0132\034.snakes.GameMe"
  "ssage.StateMsgH\000\022;\n\014announcement\030\006 \001(\0132#"
  ".snakes.GameMessage.AnnouncementMsgH\000\022+\n"
  "\004join\030\007 \001(\0132\033.snakes.GameMessage.JoinMsg"
  "H\000\022-\n\005error\030\010 \001(\0132\034.snakes.GameMessage.E"
  "rrorMsgH\000\0228\n\013role_change\030\t \001(\0132!.snakes."
  "GameMessage.RoleChangeMsgH\000\0223\n\010discover\030"
  "\014 \001(\0132\037.snakes.GameMessage.DiscoverMsgH\000"
  "\032\t\n\007PingMsg\0320\n\010SteerMsg\022$\n\tdirection\030\001 \002"
  "(\0162\021.snakes.Direction\032\010\n\006AckMsg\032,\n\010State"
  "Msg\022 \n\005state\030\001 \002(\0132\021.snakes.GameState\032:\n"
  "\017AnnouncementMsg\022\'\n\005games\030\001 \003(\0132\030.snakes"
  ".GameAnnouncement\032\r\n\013DiscoverMsg\032\213\001\n\007Joi"
  "nMsg\022.\n\013player_type\030\001 \001(\0162\022.snakes.Playe"
  "rType:\005HUMAN\022\023\n\013player_name\030\003 \002(\t\022\021\n\tgam"
  "e_name\030\004 \002(\t\022(\n\016requested_role\030\005 \002(\0162\020.s"
  "nakes.NodeRole\032!\n\010ErrorMsg\022\025\n\rerror_mess"
  "age\030\001 \002(\t\032_\n\rRoleChangeMsg\022%\n\013sender_rol"
  "e\030\001 \001(\0162\020.snakes.NodeRole\022\'\n\rreceiver_ro"
  "le\030\002 \001(\0162\020.snakes.NodeRoleB\006\n\004Type*:\n\010No"
  "deRole\022\n\n\006NORMAL\020\000\022\n\n\006MASTER\020\001\022\n\n\006DEPUTY"
  "\020\002\022\n\n\006VIEWER\020\003*\"\n\nPlayerType\022\t\n\005HUMAN\020\000\022"
  "\t\n\005ROBOT\020\001*2\n\tDirection\022\006\n\002UP\020\001\022\010\n\004DOWN\020"
  "\002\022\010\n\004LEFT\020\003\022\t\n\005RIGHT\020\004B&\n\027me.ippolitov.f"
  "it.snakesB\013SnakesProto"
  ;
static ::_pbi::once_flag descriptor_table_snakes_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_snakes_2eproto = {
    false, false, 2062, descriptor_table_protodef_snakes_2eproto,
    "snakes.proto",
    &descriptor_table_snakes_2eproto_once, nullptr, 0, 17,
    schemas, file_default_instances, TableStruct_snakes_2eproto::offsets,
    file_level_metadata_snakes_2eproto, file_level_enum_descriptors_snakes_2eproto,
    file_level_service_descriptors_snakes_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_snakes_2eproto_getter() {
  return &descriptor_table_snakes_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_snakes_2eproto(&descriptor_table_snakes_2eproto);
namespace snakes {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameState_Snake_SnakeState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_snakes_2eproto);
  return file_level_enum_descriptors_snakes_2eproto[0];
}
bool GameState_Snake_SnakeState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GameState_Snake_SnakeState GameState_Snake::ALIVE;
constexpr GameState_Snake_SnakeState GameState_Snake::ZOMBIE;
constexpr GameState_Snake_SnakeState GameState_Snake::SnakeState_MIN;
constexpr GameState_Snake_SnakeState GameState_Snake::SnakeState_MAX;
constexpr int GameState_Snake::SnakeState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeRole_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_snakes_2eproto);
  return file_level_enum_descriptors_snakes_2eproto[1];
}
bool NodeRole_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_snakes_2eproto);
  return file_level_enum_descriptors_snakes_2eproto[2];
}
bool PlayerType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Direction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_snakes_2eproto);
  return file_level_enum_descriptors_snakes_2eproto[3];
}
bool Direction_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class GamePlayer::_Internal {
 public:
  using HasBits = decltype(std::declval<GamePlayer>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ip_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_role(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_score(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000055) ^ 0x00000055) != 0;
  }
};

GamePlayer::GamePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:snakes.GamePlayer)
}
GamePlayer::GamePlayer(const GamePlayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GamePlayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.ip_address_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.port_){}
    , decltype(_impl_.role_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.score_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ip_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip_address()) {
    _this->_impl_.ip_address_.Set(from._internal_ip_address(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.score_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.score_));
  // @@protoc_insertion_point(copy_constructor:snakes.GamePlayer)
}

inline void GamePlayer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.ip_address_){}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.port_){0}
    , decltype(_impl_.role_){0}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.score_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ip_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GamePlayer::~GamePlayer() {
  // @@protoc_insertion_point(destructor:snakes.GamePlayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GamePlayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.ip_address_.Destroy();
}

void GamePlayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GamePlayer::Clear() {
// @@protoc_insertion_point(message_clear_start:snakes.GamePlayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ip_address_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.score_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.score_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GamePlayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "snakes.GamePlayer.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int32 id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ip_address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ip_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "snakes.GamePlayer.ip_address");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 port = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_port(&has_bits);
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .snakes.NodeRole role = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::snakes::NodeRole_IsValid(val))) {
            _internal_set_role(static_cast<::snakes::NodeRole>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .snakes.PlayerType type = 6 [default = HUMAN];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::snakes::PlayerType_IsValid(val))) {
            _internal_set_type(static_cast<::snakes::PlayerType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required int32 score = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_score(&has_bits);
          _impl_.score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GamePlayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:snakes.GamePlayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "snakes.GamePlayer.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required int32 id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_id(), target);
  }

  // optional string ip_address = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ip_address().data(), static_cast<int>(this->_internal_ip_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "snakes.GamePlayer.ip_address");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ip_address(), target);
  }

  // optional int32 port = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_port(), target);
  }

  // required .snakes.NodeRole role = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_role(), target);
  }

  // optional .snakes.PlayerType type = 6 [default = HUMAN];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_type(), target);
  }

  // required int32 score = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:snakes.GamePlayer)
  return target;
}

size_t GamePlayer::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:snakes.GamePlayer)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_id()) {
    // required int32 id = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  if (_internal_has_role()) {
    // required .snakes.NodeRole role = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_role());
  }

  if (_internal_has_score()) {
    // required int32 score = 7;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_score());
  }

  return total_size;
}
size_t GamePlayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:snakes.GamePlayer)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000055) ^ 0x00000055) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required int32 id = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());

    // required .snakes.NodeRole role = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_role());

    // required int32 score = 7;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_score());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string ip_address = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip_address());
  }

  // optional int32 port = 4;
  if (cached_has_bits & 0x00000008u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
  }

  // optional .snakes.PlayerType type = 6 [default = HUMAN];
  if (cached_has_bits & 0x00000020u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GamePlayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GamePlayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GamePlayer::GetClassData() const { return &_class_data_; }


void GamePlayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GamePlayer*>(&to_msg);
  auto& from = static_cast<const GamePlayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:snakes.GamePlayer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_ip_address(from._internal_ip_address());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.port_ = from._impl_.port_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.role_ = from._impl_.role_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.score_ = from._impl_.score_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GamePlayer::CopyFrom(const GamePlayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:snakes.GamePlayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GamePlayer::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GamePlayer::InternalSwap(GamePlayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ip_address_, lhs_arena,
      &other->_impl_.ip_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GamePlayer, _impl_.score_)
      + sizeof(GamePlayer::_impl_.score_)
      - PROTOBUF_FIELD_OFFSET(GamePlayer, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GamePlayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[0]);
}

// ===================================================================

class GameConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<GameConfig>()._impl_._has_bits_);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_food_static(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_state_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

GameConfig::GameConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:snakes.GameConfig)
}
GameConfig::GameConfig(const GameConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.food_static_){}
    , decltype(_impl_.state_delay_ms_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.state_delay_ms_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.state_delay_ms_));
  // @@protoc_insertion_point(copy_constructor:snakes.GameConfig)
}

inline void GameConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.width_){40}
    , decltype(_impl_.height_){30}
    , decltype(_impl_.food_static_){1}
    , decltype(_impl_.state_delay_ms_){1000}
  };
}

GameConfig::~GameConfig() {
  // @@protoc_insertion_point(destructor:snakes.GameConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:snakes.GameConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    _impl_.width_ = 40;
    _impl_.height_ = 30;
    _impl_.food_static_ = 1;
    _impl_.state_delay_ms_ = 1000;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 width = 1 [default = 40];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 height = 2 [default = 30];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 food_static = 3 [default = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_food_static(&has_bits);
          _impl_.food_static_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 state_delay_ms = 5 [default = 1000];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_state_delay_ms(&has_bits);
          _impl_.state_delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:snakes.GameConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 width = 1 [default = 40];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_width(), target);
  }

  // optional int32 height = 2 [default = 30];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_height(), target);
  }

  // optional int32 food_static = 3 [default = 1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_food_static(), target);
  }

  // optional int32 state_delay_ms = 5 [default = 1000];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_state_delay_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:snakes.GameConfig)
  return target;
}

size_t GameConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:snakes.GameConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 width = 1 [default = 40];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
    }

    // optional int32 height = 2 [default = 30];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
    }

    // optional int32 food_static = 3 [default = 1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_food_static());
    }

    // optional int32 state_delay_ms = 5 [default = 1000];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_state_delay_ms());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameConfig::GetClassData() const { return &_class_data_; }


void GameConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameConfig*>(&to_msg);
  auto& from = static_cast<const GameConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:snakes.GameConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.food_static_ = from._impl_.food_static_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.state_delay_ms_ = from._impl_.state_delay_ms_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameConfig::CopyFrom(const GameConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:snakes.GameConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameConfig::IsInitialized() const {
  return true;
}

void GameConfig::InternalSwap(GameConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.width_, other->_impl_.width_);
  swap(_impl_.height_, other->_impl_.height_);
  swap(_impl_.food_static_, other->_impl_.food_static_);
  swap(_impl_.state_delay_ms_, other->_impl_.state_delay_ms_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GameConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[1]);
}

// ===================================================================

class GamePlayers::_Internal {
 public:
};

GamePlayers::GamePlayers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:snakes.GamePlayers)
}
GamePlayers::GamePlayers(const GamePlayers& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GamePlayers* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.players_){from._impl_.players_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:snakes.GamePlayers)
}

inline void GamePlayers::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.players_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GamePlayers::~GamePlayers() {
  // @@protoc_insertion_point(destructor:snakes.GamePlayers)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GamePlayers::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.players_.~RepeatedPtrField();
}

void GamePlayers::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GamePlayers::Clear() {
// @@protoc_insertion_point(message_clear_start:snakes.GamePlayers)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.players_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GamePlayers::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .snakes.GamePlayer players = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_players(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GamePlayers::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:snakes.GamePlayers)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .snakes.GamePlayer players = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_players_size()); i < n; i++) {
    const auto& repfield = this->_internal_players(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:snakes.GamePlayers)
  return target;
}

size_t GamePlayers::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:snakes.GamePlayers)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .snakes.GamePlayer players = 1;
  total_size += 1UL * this->_internal_players_size();
  for (const auto& msg : this->_impl_.players_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GamePlayers::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GamePlayers::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GamePlayers::GetClassData() const { return &_class_data_; }


void GamePlayers::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GamePlayers*>(&to_msg);
  auto& from = static_cast<const GamePlayers&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:snakes.GamePlayers)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.players_.MergeFrom(from._impl_.players_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GamePlayers::CopyFrom(const GamePlayers& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:snakes.GamePlayers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GamePlayers::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.players_))
    return false;
  return true;
}

void GamePlayers::InternalSwap(GamePlayers* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.players_.InternalSwap(&other->_impl_.players_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GamePlayers::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[2]);
}

// ===================================================================

class GameState_Coord::_Internal {
 public:
  using HasBits = decltype(std::declval<GameState_Coord>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

GameState_Coord::GameState_Coord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:snakes.GameState.Coord)
}
GameState_Coord::GameState_Coord(const GameState_Coord& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameState_Coord* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:snakes.GameState.Coord)
}

inline void GameState_Coord::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
}

GameState_Coord::~GameState_Coord() {
  // @@protoc_insertion_point(destructor:snakes.GameState.Coord)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameState_Coord::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameState_Coord::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameState_Coord::Clear() {
// @@protoc_insertion_point(message_clear_start:snakes.GameState.Coord)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameState_Coord::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sint32 x = 1 [default = 0];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 y = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameState_Coord::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:snakes.GameState.Coord)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sint32 x = 1 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(1, this->_internal_x(), target);
  }

  // optional sint32 y = 2 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:snakes.GameState.Coord)
  return target;
}

size_t GameState_Coord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:snakes.GameState.Coord)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional sint32 x = 1 [default = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_x());
    }

    // optional sint32 y = 2 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_y());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameState_Coord::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameState_Coord::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameState_Coord::GetClassData() const { return &_class_data_; }


void GameState_Coord::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameState_Coord*>(&to_msg);
  auto& from = static_cast<const GameState_Coord&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:snakes.GameState.Coord)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameState_Coord::CopyFrom(const GameState_Coord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:snakes.GameState.Coord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameState_Coord::IsInitialized() const {
  return true;
}

void GameState_Coord::InternalSwap(GameState_Coord* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameState_Coord, _impl_.y_)
      + sizeof(GameState_Coord::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(GameState_Coord, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GameState_Coord::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[3]);
}

// ===================================================================

class GameState_Snake::_Internal {
 public:
  using HasBits = decltype(std::declval<GameState_Snake>()._impl_._has_bits_);
  static void set_has_player_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_head_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

GameState_Snake::GameState_Snake(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:snakes.GameState.Snake)
}
GameState_Snake::GameState_Snake(const GameState_Snake& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameState_Snake* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.points_){from._impl_.points_}
    , decltype(_impl_.player_id_){}
    , decltype(_impl_.state_){}
    , decltype(_impl_.head_direction_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.player_id_, &from._impl_.player_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.head_direction_) -
    reinterpret_cast<char*>(&_impl_.player_id_)) + sizeof(_impl_.head_direction_));
  // @@protoc_insertion_point(copy_constructor:snakes.GameState.Snake)
}

inline void GameState_Snake::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.points_){arena}
    , decltype(_impl_.player_id_){0}
    , decltype(_impl_.state_){0}
    , decltype(_impl_.head_direction_){1}
  };
}

GameState_Snake::~GameState_Snake() {
  // @@protoc_insertion_point(destructor:snakes.GameState.Snake)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameState_Snake::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.points_.~RepeatedPtrField();
}

void GameState_Snake::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameState_Snake::Clear() {
// @@protoc_insertion_point(message_clear_start:snakes.GameState.Snake)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.points_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.player_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.state_) -
        reinterpret_cast<char*>(&_impl_.player_id_)) + sizeof(_impl_.state_));
    _impl_.head_direction_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameState_Snake::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 player_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_id(&has_bits);
          _impl_.player_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .snakes.GameState.Coord points = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required .snakes.GameState.Snake.SnakeState state = 3 [default = ALIVE];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::snakes::GameState_Snake_SnakeState_IsValid(val))) {
            _internal_set_state(static_cast<::snakes::GameState_Snake_SnakeState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .snakes.Direction head_direction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::snakes::Direction_IsValid(val))) {
            _internal_set_head_direction(static_cast<::snakes::Direction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameState_Snake::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:snakes.GameState.Snake)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 player_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_player_id(), target);
  }

  // repeated .snakes.GameState.Coord points = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // required .snakes.GameState.Snake.SnakeState state = 3 [default = ALIVE];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_state(), target);
  }

  // required .snakes.Direction head_direction = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_head_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:snakes.GameState.Snake)
  return target;
}

size_t GameState_Snake::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:snakes.GameState.Snake)
  size_t total_size = 0;

  if (_internal_has_player_id()) {
    // required int32 player_id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_id());
  }

  if (_internal_has_state()) {
    // required .snakes.GameState.Snake.SnakeState state = 3 [default = ALIVE];
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
  }

  if (_internal_has_head_direction()) {
    // required .snakes.Direction head_direction = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_head_direction());
  }

  return total_size;
}
size_t GameState_Snake::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:snakes.GameState.Snake)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required int32 player_id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_id());

    // required .snakes.GameState.Snake.SnakeState state = 3 [default = ALIVE];
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_state());

    // required .snakes.Direction head_direction = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_head_direction());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .snakes.GameState.Coord points = 2;
  total_size += 1UL * this->_internal_points_size();
  for (const auto& msg : this->_impl_.points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameState_Snake::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameState_Snake::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameState_Snake::GetClassData() const { return &_class_data_; }


void GameState_Snake::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameState_Snake*>(&to_msg);
  auto& from = static_cast<const GameState_Snake&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:snakes.GameState.Snake)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.points_.MergeFrom(from._impl_.points_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.player_id_ = from._impl_.player_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.state_ = from._impl_.state_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.head_direction_ = from._impl_.head_direction_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameState_Snake::CopyFrom(const GameState_Snake& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:snakes.GameState.Snake)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameState_Snake::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GameState_Snake::InternalSwap(GameState_Snake* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameState_Snake, _impl_.state_)
      + sizeof(GameState_Snake::_impl_.state_)
      - PROTOBUF_FIELD_OFFSET(GameState_Snake, _impl_.player_id_)>(
          reinterpret_cast<char*>(&_impl_.player_id_),
          reinterpret_cast<char*>(&other->_impl_.player_id_));
  swap(_impl_.head_direction_, other->_impl_.head_direction_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GameState_Snake::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[4]);
}

// ===================================================================

class GameState::_Internal {
 public:
  using HasBits = decltype(std::declval<GameState>()._impl_._has_bits_);
  static void set_has_state_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::snakes::GamePlayers& players(const GameState* msg);
  static void set_has_players(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::snakes::GamePlayers&
GameState::_Internal::players(const GameState* msg) {
  return *msg->_impl_.players_;
}
GameState::GameState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:snakes.GameState)
}
GameState::GameState(const GameState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.snakes_){from._impl_.snakes_}
    , decltype(_impl_.foods_){from._impl_.foods_}
    , decltype(_impl_.players_){nullptr}
    , decltype(_impl_.state_order_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_players()) {
    _this->_impl_.players_ = new ::snakes::GamePlayers(*from._impl_.players_);
  }
  _this->_impl_.state_order_ = from._impl_.state_order_;
  // @@protoc_insertion_point(copy_constructor:snakes.GameState)
}

inline void GameState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.snakes_){arena}
    , decltype(_impl_.foods_){arena}
    , decltype(_impl_.players_){nullptr}
    , decltype(_impl_.state_order_){0}
  };
}

GameState::~GameState() {
  // @@protoc_insertion_point(destructor:snakes.GameState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.snakes_.~RepeatedPtrField();
  _impl_.foods_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.players_;
}

void GameState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameState::Clear() {
// @@protoc_insertion_point(message_clear_start:snakes.GameState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.snakes_.Clear();
  _impl_.foods_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.players_ != nullptr);
    _impl_.players_->Clear();
  }
  _impl_.state_order_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 state_order = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_state_order(&has_bits);
          _impl_.state_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .snakes.GameState.Snake snakes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_snakes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .snakes.GameState.Coord foods = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_foods(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required .snakes.GamePlayers players = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_players(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:snakes.GameState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 state_order = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_state_order(), target);
  }

  // repeated .snakes.GameState.Snake snakes = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_snakes_size()); i < n; i++) {
    const auto& repfield = this->_internal_snakes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .snakes.GameState.Coord foods = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_foods_size()); i < n; i++) {
    const auto& repfield = this->_internal_foods(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // required .snakes.GamePlayers players = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::players(this),
        _Internal::players(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:snakes.GameState)
  return target;
}

size_t GameState::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:snakes.GameState)
  size_t total_size = 0;

  if (_internal_has_players()) {
    // required .snakes.GamePlayers players = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.players_);
  }

  if (_internal_has_state_order()) {
    // required int32 state_order = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_state_order());
  }

  return total_size;
}
size_t GameState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:snakes.GameState)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .snakes.GamePlayers players = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.players_);

    // required int32 state_order = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_state_order());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .snakes.GameState.Snake snakes = 2;
  total_size += 1UL * this->_internal_snakes_size();
  for (const auto& msg : this->_impl_.snakes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .snakes.GameState.Coord foods = 3;
  total_size += 1UL * this->_internal_foods_size();
  for (const auto& msg : this->_impl_.foods_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameState::GetClassData() const { return &_class_data_; }


void GameState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameState*>(&to_msg);
  auto& from = static_cast<const GameState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:snakes.GameState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.snakes_.MergeFrom(from._impl_.snakes_);
  _this->_impl_.foods_.MergeFrom(from._impl_.foods_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_players()->::snakes::GamePlayers::MergeFrom(
          from._internal_players());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.state_order_ = from._impl_.state_order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameState::CopyFrom(const GameState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:snakes.GameState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameState::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.snakes_))
    return false;
  if (_internal_has_players()) {
    if (!_impl_.players_->IsInitialized()) return false;
  }
  return true;
}

void GameState::InternalSwap(GameState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.snakes_.InternalSwap(&other->_impl_.snakes_);
  _impl_.foods_.InternalSwap(&other->_impl_.foods_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameState, _impl_.state_order_)
      + sizeof(GameState::_impl_.state_order_)
      - PROTOBUF_FIELD_OFFSET(GameState, _impl_.players_)>(
          reinterpret_cast<char*>(&_impl_.players_),
          reinterpret_cast<char*>(&other->_impl_.players_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GameState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[5]);
}

// ===================================================================

class GameAnnouncement::_Internal {
 public:
  using HasBits = decltype(std::declval<GameAnnouncement>()._impl_._has_bits_);
  static const ::snakes::GamePlayers& players(const GameAnnouncement* msg);
  static void set_has_players(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::snakes::GameConfig& config(const GameAnnouncement* msg);
  static void set_has_config(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_can_join(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_game_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::snakes::GamePlayers&
GameAnnouncement::_Internal::players(const GameAnnouncement* msg) {
  return *msg->_impl_.players_;
}
const ::snakes::GameConfig&
GameAnnouncement::_Internal::config(const GameAnnouncement* msg) {
  return *msg->_impl_.config_;
}
GameAnnouncement::GameAnnouncement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:snakes.GameAnnouncement)
}
GameAnnouncement::GameAnnouncement(const GameAnnouncement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameAnnouncement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.game_name_){}
    , decltype(_impl_.players_){nullptr}
    , decltype(_impl_.config_){nullptr}
    , decltype(_impl_.can_join_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.game_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_name()) {
    _this->_impl_.game_name_.Set(from._internal_game_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_players()) {
    _this->_impl_.players_ = new ::snakes::GamePlayers(*from._impl_.players_);
  }
  if (from._internal_has_config()) {
    _this->_impl_.config_ = new ::snakes::GameConfig(*from._impl_.config_);
  }
  _this->_impl_.can_join_ = from._impl_.can_join_;
  // @@protoc_insertion_point(copy_constructor:snakes.GameAnnouncement)
}

inline void GameAnnouncement::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.game_name_){}
    , decltype(_impl_.players_){nullptr}
    , decltype(_impl_.config_){nullptr}
    , decltype(_impl_.can_join_){true}
  };
  _impl_.game_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GameAnnouncement::~GameAnnouncement() {
  // @@protoc_insertion_point(destructor:snakes.GameAnnouncement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameAnnouncement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.game_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.players_;
  if (this != internal_default_instance()) delete _impl_.config_;
}

void GameAnnouncement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameAnnouncement::Clear() {
// @@protoc_insertion_point(message_clear_start:snakes.GameAnnouncement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.game_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.players_ != nullptr);
      _impl_.players_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.config_ != nullptr);
      _impl_.config_->Clear();
    }
    _impl_.can_join_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameAnnouncement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .snakes.GamePlayers players = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_players(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .snakes.GameConfig config = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool can_join = 3 [default = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_can_join(&has_bits);
          _impl_.can_join_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string game_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_game_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "snakes.GameAnnouncement.game_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameAnnouncement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:snakes.GameAnnouncement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .snakes.GamePlayers players = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::players(this),
        _Internal::players(this).GetCachedSize(), target, stream);
  }

  // required .snakes.GameConfig config = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::config(this),
        _Internal::config(this).GetCachedSize(), target, stream);
  }

  // optional bool can_join = 3 [default = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_can_join(), target);
  }

  // required string game_name = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_game_name().data(), static_cast<int>(this->_internal_game_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "snakes.GameAnnouncement.game_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_game_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:snakes.GameAnnouncement)
  return target;
}

size_t GameAnnouncement::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:snakes.GameAnnouncement)
  size_t total_size = 0;

  if (_internal_has_game_name()) {
    // required string game_name = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_game_name());
  }

  if (_internal_has_players()) {
    // required .snakes.GamePlayers players = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.players_);
  }

  if (_internal_has_config()) {
    // required .snakes.GameConfig config = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.config_);
  }

  return total_size;
}
size_t GameAnnouncement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:snakes.GameAnnouncement)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string game_name = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_game_name());

    // required .snakes.GamePlayers players = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.players_);

    // required .snakes.GameConfig config = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.config_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool can_join = 3 [default = true];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameAnnouncement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameAnnouncement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameAnnouncement::GetClassData() const { return &_class_data_; }


void GameAnnouncement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameAnnouncement*>(&to_msg);
  auto& from = static_cast<const GameAnnouncement&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:snakes.GameAnnouncement)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_game_name(from._internal_game_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_players()->::snakes::GamePlayers::MergeFrom(
          from._internal_players());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_config()->::snakes::GameConfig::MergeFrom(
          from._internal_config());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.can_join_ = from._impl_.can_join_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameAnnouncement::CopyFrom(const GameAnnouncement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:snakes.GameAnnouncement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameAnnouncement::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_players()) {
    if (!_impl_.players_->IsInitialized()) return false;
  }
  return true;
}

void GameAnnouncement::InternalSwap(GameAnnouncement* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.game_name_, lhs_arena,
      &other->_impl_.game_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameAnnouncement, _impl_.config_)
      + sizeof(GameAnnouncement::_impl_.config_)
      - PROTOBUF_FIELD_OFFSET(GameAnnouncement, _impl_.players_)>(
          reinterpret_cast<char*>(&_impl_.players_),
          reinterpret_cast<char*>(&other->_impl_.players_));
  swap(_impl_.can_join_, other->_impl_.can_join_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GameAnnouncement::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[6]);
}

// ===================================================================

class GameMessage_PingMsg::_Internal {
 public:
};

GameMessage_PingMsg::GameMessage_PingMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:snakes.GameMessage.PingMsg)
}
GameMessage_PingMsg::GameMessage_PingMsg(const GameMessage_PingMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  GameMessage_PingMsg* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:snakes.GameMessage.PingMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameMessage_PingMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameMessage_PingMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata GameMessage_PingMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[7]);
}

// ===================================================================

class GameMessage_SteerMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<GameMessage_SteerMsg>()._impl_._has_bits_);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

GameMessage_SteerMsg::GameMessage_SteerMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:snakes.GameMessage.SteerMsg)
}
GameMessage_SteerMsg::GameMessage_SteerMsg(const GameMessage_SteerMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameMessage_SteerMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.direction_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.direction_ = from._impl_.direction_;
  // @@protoc_insertion_point(copy_constructor:snakes.GameMessage.SteerMsg)
}

inline void GameMessage_SteerMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.direction_){1}
  };
}

GameMessage_SteerMsg::~GameMessage_SteerMsg() {
  // @@protoc_insertion_point(destructor:snakes.GameMessage.SteerMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameMessage_SteerMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameMessage_SteerMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameMessage_SteerMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:snakes.GameMessage.SteerMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.direction_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameMessage_SteerMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .snakes.Direction direction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::snakes::Direction_IsValid(val))) {
            _internal_set_direction(static_cast<::snakes::Direction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameMessage_SteerMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:snakes.GameMessage.SteerMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .snakes.Direction direction = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:snakes.GameMessage.SteerMsg)
  return target;
}

size_t GameMessage_SteerMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:snakes.GameMessage.SteerMsg)
  size_t total_size = 0;

  // required .snakes.Direction direction = 1;
  if (_internal_has_direction()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameMessage_SteerMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameMessage_SteerMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameMessage_SteerMsg::GetClassData() const { return &_class_data_; }


void GameMessage_SteerMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameMessage_SteerMsg*>(&to_msg);
  auto& from = static_cast<const GameMessage_SteerMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:snakes.GameMessage.SteerMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_direction()) {
    _this->_internal_set_direction(from._internal_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameMessage_SteerMsg::CopyFrom(const GameMessage_SteerMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:snakes.GameMessage.SteerMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameMessage_SteerMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GameMessage_SteerMsg::InternalSwap(GameMessage_SteerMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.direction_, other->_impl_.direction_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GameMessage_SteerMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[8]);
}

// ===================================================================

class GameMessage_AckMsg::_Internal {
 public:
};

GameMessage_AckMsg::GameMessage_AckMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:snakes.GameMessage.AckMsg)
}
GameMessage_AckMsg::GameMessage_AckMsg(const GameMessage_AckMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  GameMessage_AckMsg* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:snakes.GameMessage.AckMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameMessage_AckMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameMessage_AckMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata GameMessage_AckMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[9]);
}

// ===================================================================

class GameMessage_StateMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<GameMessage_StateMsg>()._impl_._has_bits_);
  static const ::snakes::GameState& state(const GameMessage_StateMsg* msg);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::snakes::GameState&
GameMessage_StateMsg::_Internal::state(const GameMessage_StateMsg* msg) {
  return *msg->_impl_.state_;
}
GameMessage_StateMsg::GameMessage_StateMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:snakes.GameMessage.StateMsg)
}
GameMessage_StateMsg::GameMessage_StateMsg(const GameMessage_StateMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameMessage_StateMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.state_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_state()) {
    _this->_impl_.state_ = new ::snakes::GameState(*from._impl_.state_);
  }
  // @@protoc_insertion_point(copy_constructor:snakes.GameMessage.StateMsg)
}

inline void GameMessage_StateMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.state_){nullptr}
  };
}

GameMessage_StateMsg::~GameMessage_StateMsg() {
  // @@protoc_insertion_point(destructor:snakes.GameMessage.StateMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameMessage_StateMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.state_;
}

void GameMessage_StateMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameMessage_StateMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:snakes.GameMessage.StateMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.state_ != nullptr);
    _impl_.state_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameMessage_StateMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .snakes.GameState state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameMessage_StateMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:snakes.GameMessage.StateMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .snakes.GameState state = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::state(this),
        _Internal::state(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:snakes.GameMessage.StateMsg)
  return target;
}

size_t GameMessage_StateMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:snakes.GameMessage.StateMsg)
  size_t total_size = 0;

  // required .snakes.GameState state = 1;
  if (_internal_has_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.state_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameMessage_StateMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameMessage_StateMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameMessage_StateMsg::GetClassData() const { return &_class_data_; }


void GameMessage_StateMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameMessage_StateMsg*>(&to_msg);
  auto& from = static_cast<const GameMessage_StateMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:snakes.GameMessage.StateMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_state()) {
    _this->_internal_mutable_state()->::snakes::GameState::MergeFrom(
        from._internal_state());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameMessage_StateMsg::CopyFrom(const GameMessage_StateMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:snakes.GameMessage.StateMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameMessage_StateMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_state()) {
    if (!_impl_.state_->IsInitialized()) return false;
  }
  return true;
}

void GameMessage_StateMsg::InternalSwap(GameMessage_StateMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.state_, other->_impl_.state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GameMessage_StateMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[10]);
}

// ===================================================================

class GameMessage_AnnouncementMsg::_Internal {
 public:
};

GameMessage_AnnouncementMsg::GameMessage_AnnouncementMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:snakes.GameMessage.AnnouncementMsg)
}
GameMessage_AnnouncementMsg::GameMessage_AnnouncementMsg(const GameMessage_AnnouncementMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameMessage_AnnouncementMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.games_){from._impl_.games_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:snakes.GameMessage.AnnouncementMsg)
}

inline void GameMessage_AnnouncementMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.games_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GameMessage_AnnouncementMsg::~GameMessage_AnnouncementMsg() {
  // @@protoc_insertion_point(destructor:snakes.GameMessage.AnnouncementMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameMessage_AnnouncementMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.games_.~RepeatedPtrField();
}

void GameMessage_AnnouncementMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameMessage_AnnouncementMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:snakes.GameMessage.AnnouncementMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.games_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameMessage_AnnouncementMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .snakes.GameAnnouncement games = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_games(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameMessage_AnnouncementMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:snakes.GameMessage.AnnouncementMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .snakes.GameAnnouncement games = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_games_size()); i < n; i++) {
    const auto& repfield = this->_internal_games(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:snakes.GameMessage.AnnouncementMsg)
  return target;
}

size_t GameMessage_AnnouncementMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:snakes.GameMessage.AnnouncementMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .snakes.GameAnnouncement games = 1;
  total_size += 1UL * this->_internal_games_size();
  for (const auto& msg : this->_impl_.games_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameMessage_AnnouncementMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameMessage_AnnouncementMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameMessage_AnnouncementMsg::GetClassData() const { return &_class_data_; }


void GameMessage_AnnouncementMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameMessage_AnnouncementMsg*>(&to_msg);
  auto& from = static_cast<const GameMessage_AnnouncementMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:snakes.GameMessage.AnnouncementMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.games_.MergeFrom(from._impl_.games_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameMessage_AnnouncementMsg::CopyFrom(const GameMessage_AnnouncementMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:snakes.GameMessage.AnnouncementMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameMessage_AnnouncementMsg::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.games_))
    return false;
  return true;
}

void GameMessage_AnnouncementMsg::InternalSwap(GameMessage_AnnouncementMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.games_.InternalSwap(&other->_impl_.games_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GameMessage_AnnouncementMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[11]);
}

// ===================================================================

class GameMessage_DiscoverMsg::_Internal {
 public:
};

GameMessage_DiscoverMsg::GameMessage_DiscoverMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:snakes.GameMessage.DiscoverMsg)
}
GameMessage_DiscoverMsg::GameMessage_DiscoverMsg(const GameMessage_DiscoverMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  GameMessage_DiscoverMsg* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:snakes.GameMessage.DiscoverMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameMessage_DiscoverMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameMessage_DiscoverMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata GameMessage_DiscoverMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[12]);
}

// ===================================================================

class GameMessage_JoinMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<GameMessage_JoinMsg>()._impl_._has_bits_);
  static void set_has_player_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_player_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_game_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_requested_role(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000b) ^ 0x0000000b) != 0;
  }
};

GameMessage_JoinMsg::GameMessage_JoinMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:snakes.GameMessage.JoinMsg)
}
GameMessage_JoinMsg::GameMessage_JoinMsg(const GameMessage_JoinMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameMessage_JoinMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_name_){}
    , decltype(_impl_.game_name_){}
    , decltype(_impl_.player_type_){}
    , decltype(_impl_.requested_role_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.player_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.player_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_player_name()) {
    _this->_impl_.player_name_.Set(from._internal_player_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.game_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_name()) {
    _this->_impl_.game_name_.Set(from._internal_game_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.player_type_, &from._impl_.player_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.requested_role_) -
    reinterpret_cast<char*>(&_impl_.player_type_)) + sizeof(_impl_.requested_role_));
  // @@protoc_insertion_point(copy_constructor:snakes.GameMessage.JoinMsg)
}

inline void GameMessage_JoinMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.player_name_){}
    , decltype(_impl_.game_name_){}
    , decltype(_impl_.player_type_){0}
    , decltype(_impl_.requested_role_){0}
  };
  _impl_.player_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.player_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.game_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GameMessage_JoinMsg::~GameMessage_JoinMsg() {
  // @@protoc_insertion_point(destructor:snakes.GameMessage.JoinMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameMessage_JoinMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.player_name_.Destroy();
  _impl_.game_name_.Destroy();
}

void GameMessage_JoinMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameMessage_JoinMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:snakes.GameMessage.JoinMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.player_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.game_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.player_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.requested_role_) -
        reinterpret_cast<char*>(&_impl_.player_type_)) + sizeof(_impl_.requested_role_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameMessage_JoinMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .snakes.PlayerType player_type = 1 [default = HUMAN];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::snakes::PlayerType_IsValid(val))) {
            _internal_set_player_type(static_cast<::snakes::PlayerType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required string player_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_player_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "snakes.GameMessage.JoinMsg.player_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string game_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_game_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "snakes.GameMessage.JoinMsg.game_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required .snakes.NodeRole requested_role = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::snakes::NodeRole_IsValid(val))) {
            _internal_set_requested_role(static_cast<::snakes::NodeRole>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameMessage_JoinMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:snakes.GameMessage.JoinMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .snakes.PlayerType player_type = 1 [default = HUMAN];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_player_type(), target);
  }

  // required string player_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_player_name().data(), static_cast<int>(this->_internal_player_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "snakes.GameMessage.JoinMsg.player_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_player_name(), target);
  }

  // required string game_name = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_game_name().data(), static_cast<int>(this->_internal_game_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "snakes.GameMessage.JoinMsg.game_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_game_name(), target);
  }

  // required .snakes.NodeRole requested_role = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_requested_role(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:snakes.GameMessage.JoinMsg)
  return target;
}

size_t GameMessage_JoinMsg::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:snakes.GameMessage.JoinMsg)
  size_t total_size = 0;

  if (_internal_has_player_name()) {
    // required string player_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_player_name());
  }

  if (_internal_has_game_name()) {
    // required string game_name = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_game_name());
  }

  if (_internal_has_requested_role()) {
    // required .snakes.NodeRole requested_role = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_requested_role());
  }

  return total_size;
}
size_t GameMessage_JoinMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:snakes.GameMessage.JoinMsg)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000b) ^ 0x0000000b) == 0) {  // All required fields are present.
    // required string player_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_player_name());

    // required string game_name = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_game_name());

    // required .snakes.NodeRole requested_role = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_requested_role());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .snakes.PlayerType player_type = 1 [default = HUMAN];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_player_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameMessage_JoinMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameMessage_JoinMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameMessage_JoinMsg::GetClassData() const { return &_class_data_; }


void GameMessage_JoinMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameMessage_JoinMsg*>(&to_msg);
  auto& from = static_cast<const GameMessage_JoinMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:snakes.GameMessage.JoinMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_player_name(from._internal_player_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_game_name(from._internal_game_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.player_type_ = from._impl_.player_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.requested_role_ = from._impl_.requested_role_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameMessage_JoinMsg::CopyFrom(const GameMessage_JoinMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:snakes.GameMessage.JoinMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameMessage_JoinMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GameMessage_JoinMsg::InternalSwap(GameMessage_JoinMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.player_name_, lhs_arena,
      &other->_impl_.player_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.game_name_, lhs_arena,
      &other->_impl_.game_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameMessage_JoinMsg, _impl_.requested_role_)
      + sizeof(GameMessage_JoinMsg::_impl_.requested_role_)
      - PROTOBUF_FIELD_OFFSET(GameMessage_JoinMsg, _impl_.player_type_)>(
          reinterpret_cast<char*>(&_impl_.player_type_),
          reinterpret_cast<char*>(&other->_impl_.player_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GameMessage_JoinMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[13]);
}

// ===================================================================

class GameMessage_ErrorMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<GameMessage_ErrorMsg>()._impl_._has_bits_);
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

GameMessage_ErrorMsg::GameMessage_ErrorMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:snakes.GameMessage.ErrorMsg)
}
GameMessage_ErrorMsg::GameMessage_ErrorMsg(const GameMessage_ErrorMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameMessage_ErrorMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_message_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error_message()) {
    _this->_impl_.error_message_.Set(from._internal_error_message(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:snakes.GameMessage.ErrorMsg)
}

inline void GameMessage_ErrorMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_message_){}
  };
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GameMessage_ErrorMsg::~GameMessage_ErrorMsg() {
  // @@protoc_insertion_point(destructor:snakes.GameMessage.ErrorMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameMessage_ErrorMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_message_.Destroy();
}

void GameMessage_ErrorMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameMessage_ErrorMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:snakes.GameMessage.ErrorMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.error_message_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameMessage_ErrorMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string error_message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "snakes.GameMessage.ErrorMsg.error_message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameMessage_ErrorMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:snakes.GameMessage.ErrorMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string error_message = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_error_message().data(), static_cast<int>(this->_internal_error_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "snakes.GameMessage.ErrorMsg.error_message");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_error_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:snakes.GameMessage.ErrorMsg)
  return target;
}

size_t GameMessage_ErrorMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:snakes.GameMessage.ErrorMsg)
  size_t total_size = 0;

  // required string error_message = 1;
  if (_internal_has_error_message()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error_message());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameMessage_ErrorMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameMessage_ErrorMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameMessage_ErrorMsg::GetClassData() const { return &_class_data_; }


void GameMessage_ErrorMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameMessage_ErrorMsg*>(&to_msg);
  auto& from = static_cast<const GameMessage_ErrorMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:snakes.GameMessage.ErrorMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_error_message()) {
    _this->_internal_set_error_message(from._internal_error_message());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameMessage_ErrorMsg::CopyFrom(const GameMessage_ErrorMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:snakes.GameMessage.ErrorMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameMessage_ErrorMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GameMessage_ErrorMsg::InternalSwap(GameMessage_ErrorMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_message_, lhs_arena,
      &other->_impl_.error_message_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GameMessage_ErrorMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[14]);
}

// ===================================================================

class GameMessage_RoleChangeMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<GameMessage_RoleChangeMsg>()._impl_._has_bits_);
  static void set_has_sender_role(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_receiver_role(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

GameMessage_RoleChangeMsg::GameMessage_RoleChangeMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:snakes.GameMessage.RoleChangeMsg)
}
GameMessage_RoleChangeMsg::GameMessage_RoleChangeMsg(const GameMessage_RoleChangeMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameMessage_RoleChangeMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sender_role_){}
    , decltype(_impl_.receiver_role_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.sender_role_, &from._impl_.sender_role_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.receiver_role_) -
    reinterpret_cast<char*>(&_impl_.sender_role_)) + sizeof(_impl_.receiver_role_));
  // @@protoc_insertion_point(copy_constructor:snakes.GameMessage.RoleChangeMsg)
}

inline void GameMessage_RoleChangeMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sender_role_){0}
    , decltype(_impl_.receiver_role_){0}
  };
}

GameMessage_RoleChangeMsg::~GameMessage_RoleChangeMsg() {
  // @@protoc_insertion_point(destructor:snakes.GameMessage.RoleChangeMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameMessage_RoleChangeMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameMessage_RoleChangeMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameMessage_RoleChangeMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:snakes.GameMessage.RoleChangeMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.sender_role_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.receiver_role_) -
        reinterpret_cast<char*>(&_impl_.sender_role_)) + sizeof(_impl_.receiver_role_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameMessage_RoleChangeMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .snakes.NodeRole sender_role = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::snakes::NodeRole_IsValid(val))) {
            _internal_set_sender_role(static_cast<::snakes::NodeRole>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .snakes.NodeRole receiver_role = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::snakes::NodeRole_IsValid(val))) {
            _internal_set_receiver_role(static_cast<::snakes::NodeRole>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameMessage_RoleChangeMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:snakes.GameMessage.RoleChangeMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .snakes.NodeRole sender_role = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_sender_role(), target);
  }

  // optional .snakes.NodeRole receiver_role = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_receiver_role(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:snakes.GameMessage.RoleChangeMsg)
  return target;
}

size_t GameMessage_RoleChangeMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:snakes.GameMessage.RoleChangeMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .snakes.NodeRole sender_role = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_sender_role());
    }

    // optional .snakes.NodeRole receiver_role = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_receiver_role());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameMessage_RoleChangeMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameMessage_RoleChangeMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameMessage_RoleChangeMsg::GetClassData() const { return &_class_data_; }


void GameMessage_RoleChangeMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameMessage_RoleChangeMsg*>(&to_msg);
  auto& from = static_cast<const GameMessage_RoleChangeMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:snakes.GameMessage.RoleChangeMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.sender_role_ = from._impl_.sender_role_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.receiver_role_ = from._impl_.receiver_role_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameMessage_RoleChangeMsg::CopyFrom(const GameMessage_RoleChangeMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:snakes.GameMessage.RoleChangeMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameMessage_RoleChangeMsg::IsInitialized() const {
  return true;
}

void GameMessage_RoleChangeMsg::InternalSwap(GameMessage_RoleChangeMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameMessage_RoleChangeMsg, _impl_.receiver_role_)
      + sizeof(GameMessage_RoleChangeMsg::_impl_.receiver_role_)
      - PROTOBUF_FIELD_OFFSET(GameMessage_RoleChangeMsg, _impl_.sender_role_)>(
          reinterpret_cast<char*>(&_impl_.sender_role_),
          reinterpret_cast<char*>(&other->_impl_.sender_role_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GameMessage_RoleChangeMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[15]);
}

// ===================================================================

class GameMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GameMessage>()._impl_._has_bits_);
  static void set_has_msg_seq(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sender_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_receiver_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::snakes::GameMessage_PingMsg& ping(const GameMessage* msg);
  static const ::snakes::GameMessage_SteerMsg& steer(const GameMessage* msg);
  static const ::snakes::GameMessage_AckMsg& ack(const GameMessage* msg);
  static const ::snakes::GameMessage_StateMsg& state(const GameMessage* msg);
  static const ::snakes::GameMessage_AnnouncementMsg& announcement(const GameMessage* msg);
  static const ::snakes::GameMessage_JoinMsg& join(const GameMessage* msg);
  static const ::snakes::GameMessage_ErrorMsg& error(const GameMessage* msg);
  static const ::snakes::GameMessage_RoleChangeMsg& role_change(const GameMessage* msg);
  static const ::snakes::GameMessage_DiscoverMsg& discover(const GameMessage* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::snakes::GameMessage_PingMsg&
GameMessage::_Internal::ping(const GameMessage* msg) {
  return *msg->_impl_.Type_.ping_;
}
const ::snakes::GameMessage_SteerMsg&
GameMessage::_Internal::steer(const GameMessage* msg) {
  return *msg->_impl_.Type_.steer_;
}
const ::snakes::GameMessage_AckMsg&
GameMessage::_Internal::ack(const GameMessage* msg) {
  return *msg->_impl_.Type_.ack_;
}
const ::snakes::GameMessage_StateMsg&
GameMessage::_Internal::state(const GameMessage* msg) {
  return *msg->_impl_.Type_.state_;
}
const ::snakes::GameMessage_AnnouncementMsg&
GameMessage::_Internal::announcement(const GameMessage* msg) {
  return *msg->_impl_.Type_.announcement_;
}
const ::snakes::GameMessage_JoinMsg&
GameMessage::_Internal::join(const GameMessage* msg) {
  return *msg->_impl_.Type_.join_;
}
const ::snakes::GameMessage_ErrorMsg&
GameMessage::_Internal::error(const GameMessage* msg) {
  return *msg->_impl_.Type_.error_;
}
const ::snakes::GameMessage_RoleChangeMsg&
GameMessage::_Internal::role_change(const GameMessage* msg) {
  return *msg->_impl_.Type_.role_change_;
}
const ::snakes::GameMessage_DiscoverMsg&
GameMessage::_Internal::discover(const GameMessage* msg) {
  return *msg->_impl_.Type_.discover_;
}
void GameMessage::set_allocated_ping(::snakes::GameMessage_PingMsg* ping) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (ping) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ping);
    if (message_arena != submessage_arena) {
      ping = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ping, submessage_arena);
    }
    set_has_ping();
    _impl_.Type_.ping_ = ping;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.ping)
}
void GameMessage::set_allocated_steer(::snakes::GameMessage_SteerMsg* steer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (steer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(steer);
    if (message_arena != submessage_arena) {
      steer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, steer, submessage_arena);
    }
    set_has_steer();
    _impl_.Type_.steer_ = steer;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.steer)
}
void GameMessage::set_allocated_ack(::snakes::GameMessage_AckMsg* ack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (ack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ack);
    if (message_arena != submessage_arena) {
      ack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ack, submessage_arena);
    }
    set_has_ack();
    _impl_.Type_.ack_ = ack;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.ack)
}
void GameMessage::set_allocated_state(::snakes::GameMessage_StateMsg* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    set_has_state();
    _impl_.Type_.state_ = state;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.state)
}
void GameMessage::set_allocated_announcement(::snakes::GameMessage_AnnouncementMsg* announcement) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (announcement) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(announcement);
    if (message_arena != submessage_arena) {
      announcement = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, announcement, submessage_arena);
    }
    set_has_announcement();
    _impl_.Type_.announcement_ = announcement;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.announcement)
}
void GameMessage::set_allocated_join(::snakes::GameMessage_JoinMsg* join) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (join) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(join);
    if (message_arena != submessage_arena) {
      join = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, join, submessage_arena);
    }
    set_has_join();
    _impl_.Type_.join_ = join;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.join)
}
void GameMessage::set_allocated_error(::snakes::GameMessage_ErrorMsg* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
    _impl_.Type_.error_ = error;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.error)
}
void GameMessage::set_allocated_role_change(::snakes::GameMessage_RoleChangeMsg* role_change) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (role_change) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(role_change);
    if (message_arena != submessage_arena) {
      role_change = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role_change, submessage_arena);
    }
    set_has_role_change();
    _impl_.Type_.role_change_ = role_change;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.role_change)
}
void GameMessage::set_allocated_discover(::snakes::GameMessage_DiscoverMsg* discover) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Type();
  if (discover) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(discover);
    if (message_arena != submessage_arena) {
      discover = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, discover, submessage_arena);
    }
    set_has_discover();
    _impl_.Type_.discover_ = discover;
  }
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.discover)
}
GameMessage::GameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:snakes.GameMessage)
}
GameMessage::GameMessage(const GameMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_seq_){}
    , decltype(_impl_.sender_id_){}
    , decltype(_impl_.receiver_id_){}
    , decltype(_impl_.Type_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.msg_seq_, &from._impl_.msg_seq_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.receiver_id_) -
    reinterpret_cast<char*>(&_impl_.msg_seq_)) + sizeof(_impl_.receiver_id_));
  clear_has_Type();
  switch (from.Type_case()) {
    case kPing: {
      _this->_internal_mutable_ping()->::snakes::GameMessage_PingMsg::MergeFrom(
          from._internal_ping());
      break;
    }
    case kSteer: {
      _this->_internal_mutable_steer()->::snakes::GameMessage_SteerMsg::MergeFrom(
          from._internal_steer());
      break;
    }
    case kAck: {
      _this->_internal_mutable_ack()->::snakes::GameMessage_AckMsg::MergeFrom(
          from._internal_ack());
      break;
    }
    case kState: {
      _this->_internal_mutable_state()->::snakes::GameMessage_StateMsg::MergeFrom(
          from._internal_state());
      break;
    }
    case kAnnouncement: {
      _this->_internal_mutable_announcement()->::snakes::GameMessage_AnnouncementMsg::MergeFrom(
          from._internal_announcement());
      break;
    }
    case kJoin: {
      _this->_internal_mutable_join()->::snakes::GameMessage_JoinMsg::MergeFrom(
          from._internal_join());
      break;
    }
    case kError: {
      _this->_internal_mutable_error()->::snakes::GameMessage_ErrorMsg::MergeFrom(
          from._internal_error());
      break;
    }
    case kRoleChange: {
      _this->_internal_mutable_role_change()->::snakes::GameMessage_RoleChangeMsg::MergeFrom(
          from._internal_role_change());
      break;
    }
    case kDiscover: {
      _this->_internal_mutable_discover()->::snakes::GameMessage_DiscoverMsg::MergeFrom(
          from._internal_discover());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:snakes.GameMessage)
}

inline void GameMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_seq_){int64_t{0}}
    , decltype(_impl_.sender_id_){0}
    , decltype(_impl_.receiver_id_){0}
    , decltype(_impl_.Type_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_Type();
}

GameMessage::~GameMessage() {
  // @@protoc_insertion_point(destructor:snakes.GameMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_Type()) {
    clear_Type();
  }
}

void GameMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameMessage::clear_Type() {
// @@protoc_insertion_point(one_of_clear_start:snakes.GameMessage)
  switch (Type_case()) {
    case kPing: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Type_.ping_;
      }
      break;
    }
    case kSteer: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Type_.steer_;
      }
      break;
    }
    case kAck: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Type_.ack_;
      }
      break;
    }
    case kState: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Type_.state_;
      }
      break;
    }
    case kAnnouncement: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Type_.announcement_;
      }
      break;
    }
    case kJoin: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Type_.join_;
      }
      break;
    }
    case kError: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Type_.error_;
      }
      break;
    }
    case kRoleChange: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Type_.role_change_;
      }
      break;
    }
    case kDiscover: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Type_.discover_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}


void GameMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:snakes.GameMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.msg_seq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.receiver_id_) -
        reinterpret_cast<char*>(&_impl_.msg_seq_)) + sizeof(_impl_.receiver_id_));
  }
  clear_Type();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 msg_seq = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msg_seq(&has_bits);
          _impl_.msg_seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .snakes.GameMessage.PingMsg ping = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ping(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .snakes.GameMessage.SteerMsg steer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_steer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .snakes.GameMessage.AckMsg ack = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ack(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .snakes.GameMessage.StateMsg state = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .snakes.GameMessage.AnnouncementMsg announcement = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_announcement(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .snakes.GameMessage.JoinMsg join = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_join(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .snakes.GameMessage.ErrorMsg error = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_error(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .snakes.GameMessage.RoleChangeMsg role_change = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_role_change(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sender_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_sender_id(&has_bits);
          _impl_.sender_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 receiver_id = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_receiver_id(&has_bits);
          _impl_.receiver_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .snakes.GameMessage.DiscoverMsg discover = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_discover(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:snakes.GameMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 msg_seq = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_msg_seq(), target);
  }

  switch (Type_case()) {
    case kPing: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::ping(this),
          _Internal::ping(this).GetCachedSize(), target, stream);
      break;
    }
    case kSteer: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::steer(this),
          _Internal::steer(this).GetCachedSize(), target, stream);
      break;
    }
    case kAck: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::ack(this),
          _Internal::ack(this).GetCachedSize(), target, stream);
      break;
    }
    case kState: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::state(this),
          _Internal::state(this).GetCachedSize(), target, stream);
      break;
    }
    case kAnnouncement: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::announcement(this),
          _Internal::announcement(this).GetCachedSize(), target, stream);
      break;
    }
    case kJoin: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::join(this),
          _Internal::join(this).GetCachedSize(), target, stream);
      break;
    }
    case kError: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::error(this),
          _Internal::error(this).GetCachedSize(), target, stream);
      break;
    }
    case kRoleChange: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::role_change(this),
          _Internal::role_change(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  // optional int32 sender_id = 10;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_sender_id(), target);
  }

  // optional int32 receiver_id = 11;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_receiver_id(), target);
  }

  // .snakes.GameMessage.DiscoverMsg discover = 12;
  if (_internal_has_discover()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::discover(this),
        _Internal::discover(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:snakes.GameMessage)
  return target;
}

size_t GameMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:snakes.GameMessage)
  size_t total_size = 0;

  // required int64 msg_seq = 1;
  if (_internal_has_msg_seq()) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_msg_seq());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional int32 sender_id = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sender_id());
    }

    // optional int32 receiver_id = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_receiver_id());
    }

  }
  switch (Type_case()) {
    // .snakes.GameMessage.PingMsg ping = 2;
    case kPing: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Type_.ping_);
      break;
    }
    // .snakes.GameMessage.SteerMsg steer = 3;
    case kSteer: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Type_.steer_);
      break;
    }
    // .snakes.GameMessage.AckMsg ack = 4;
    case kAck: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Type_.ack_);
      break;
    }
    // .snakes.GameMessage.StateMsg state = 5;
    case kState: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Type_.state_);
      break;
    }
    // .snakes.GameMessage.AnnouncementMsg announcement = 6;
    case kAnnouncement: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Type_.announcement_);
      break;
    }
    // .snakes.GameMessage.JoinMsg join = 7;
    case kJoin: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Type_.join_);
      break;
    }
    // .snakes.GameMessage.ErrorMsg error = 8;
    case kError: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Type_.error_);
      break;
    }
    // .snakes.GameMessage.RoleChangeMsg role_change = 9;
    case kRoleChange: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Type_.role_change_);
      break;
    }
    // .snakes.GameMessage.DiscoverMsg discover = 12;
    case kDiscover: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Type_.discover_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameMessage::GetClassData() const { return &_class_data_; }


void GameMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameMessage*>(&to_msg);
  auto& from = static_cast<const GameMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:snakes.GameMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.msg_seq_ = from._impl_.msg_seq_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.sender_id_ = from._impl_.sender_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.receiver_id_ = from._impl_.receiver_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.Type_case()) {
    case kPing: {
      _this->_internal_mutable_ping()->::snakes::GameMessage_PingMsg::MergeFrom(
          from._internal_ping());
      break;
    }
    case kSteer: {
      _this->_internal_mutable_steer()->::snakes::GameMessage_SteerMsg::MergeFrom(
          from._internal_steer());
      break;
    }
    case kAck: {
      _this->_internal_mutable_ack()->::snakes::GameMessage_AckMsg::MergeFrom(
          from._internal_ack());
      break;
    }
    case kState: {
      _this->_internal_mutable_state()->::snakes::GameMessage_StateMsg::MergeFrom(
          from._internal_state());
      break;
    }
    case kAnnouncement: {
      _this->_internal_mutable_announcement()->::snakes::GameMessage_AnnouncementMsg::MergeFrom(
          from._internal_announcement());
      break;
    }
    case kJoin: {
      _this->_internal_mutable_join()->::snakes::GameMessage_JoinMsg::MergeFrom(
          from._internal_join());
      break;
    }
    case kError: {
      _this->_internal_mutable_error()->::snakes::GameMessage_ErrorMsg::MergeFrom(
          from._internal_error());
      break;
    }
    case kRoleChange: {
      _this->_internal_mutable_role_change()->::snakes::GameMessage_RoleChangeMsg::MergeFrom(
          from._internal_role_change());
      break;
    }
    case kDiscover: {
      _this->_internal_mutable_discover()->::snakes::GameMessage_DiscoverMsg::MergeFrom(
          from._internal_discover());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameMessage::CopyFrom(const GameMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:snakes.GameMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  switch (Type_case()) {
    case kPing: {
      break;
    }
    case kSteer: {
      if (_internal_has_steer()) {
        if (!_impl_.Type_.steer_->IsInitialized()) return false;
      }
      break;
    }
    case kAck: {
      break;
    }
    case kState: {
      if (_internal_has_state()) {
        if (!_impl_.Type_.state_->IsInitialized()) return false;
      }
      break;
    }
    case kAnnouncement: {
      if (_internal_has_announcement()) {
        if (!_impl_.Type_.announcement_->IsInitialized()) return false;
      }
      break;
    }
    case kJoin: {
      if (_internal_has_join()) {
        if (!_impl_.Type_.join_->IsInitialized()) return false;
      }
      break;
    }
    case kError: {
      if (_internal_has_error()) {
        if (!_impl_.Type_.error_->IsInitialized()) return false;
      }
      break;
    }
    case kRoleChange: {
      break;
    }
    case kDiscover: {
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  return true;
}

void GameMessage::InternalSwap(GameMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameMessage, _impl_.receiver_id_)
      + sizeof(GameMessage::_impl_.receiver_id_)
      - PROTOBUF_FIELD_OFFSET(GameMessage, _impl_.msg_seq_)>(
          reinterpret_cast<char*>(&_impl_.msg_seq_),
          reinterpret_cast<char*>(&other->_impl_.msg_seq_));
  swap(_impl_.Type_, other->_impl_.Type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata GameMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_snakes_2eproto_getter, &descriptor_table_snakes_2eproto_once,
      file_level_metadata_snakes_2eproto[16]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace snakes
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::snakes::GamePlayer*
Arena::CreateMaybeMessage< ::snakes::GamePlayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GamePlayer >(arena);
}
template<> PROTOBUF_NOINLINE ::snakes::GameConfig*
Arena::CreateMaybeMessage< ::snakes::GameConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GameConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::snakes::GamePlayers*
Arena::CreateMaybeMessage< ::snakes::GamePlayers >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GamePlayers >(arena);
}
template<> PROTOBUF_NOINLINE ::snakes::GameState_Coord*
Arena::CreateMaybeMessage< ::snakes::GameState_Coord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GameState_Coord >(arena);
}
template<> PROTOBUF_NOINLINE ::snakes::GameState_Snake*
Arena::CreateMaybeMessage< ::snakes::GameState_Snake >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GameState_Snake >(arena);
}
template<> PROTOBUF_NOINLINE ::snakes::GameState*
Arena::CreateMaybeMessage< ::snakes::GameState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GameState >(arena);
}
template<> PROTOBUF_NOINLINE ::snakes::GameAnnouncement*
Arena::CreateMaybeMessage< ::snakes::GameAnnouncement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GameAnnouncement >(arena);
}
template<> PROTOBUF_NOINLINE ::snakes::GameMessage_PingMsg*
Arena::CreateMaybeMessage< ::snakes::GameMessage_PingMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GameMessage_PingMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::snakes::GameMessage_SteerMsg*
Arena::CreateMaybeMessage< ::snakes::GameMessage_SteerMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GameMessage_SteerMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::snakes::GameMessage_AckMsg*
Arena::CreateMaybeMessage< ::snakes::GameMessage_AckMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GameMessage_AckMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::snakes::GameMessage_StateMsg*
Arena::CreateMaybeMessage< ::snakes::GameMessage_StateMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GameMessage_StateMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::snakes::GameMessage_AnnouncementMsg*
Arena::CreateMaybeMessage< ::snakes::GameMessage_AnnouncementMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GameMessage_AnnouncementMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::snakes::GameMessage_DiscoverMsg*
Arena::CreateMaybeMessage< ::snakes::GameMessage_DiscoverMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GameMessage_DiscoverMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::snakes::GameMessage_JoinMsg*
Arena::CreateMaybeMessage< ::snakes::GameMessage_JoinMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GameMessage_JoinMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::snakes::GameMessage_ErrorMsg*
Arena::CreateMaybeMessage< ::snakes::GameMessage_ErrorMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GameMessage_ErrorMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::snakes::GameMessage_RoleChangeMsg*
Arena::CreateMaybeMessage< ::snakes::GameMessage_RoleChangeMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GameMessage_RoleChangeMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::snakes::GameMessage*
Arena::CreateMaybeMessage< ::snakes::GameMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::snakes::GameMessage >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
